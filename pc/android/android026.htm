<html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Android实时监控项目第四篇：后台线程发送预览帧视频数据 - 兰亭风雨的专栏 - CSDN博客</title>
  <link href="images/style.css" rel="stylesheet">
</head>

<body class="stackedit"><div class="stackedit__html">

<div class="article_content clearfix" id="article_content" style="overflow: hidden;">
                                            <div class="article-copyright">
                <span class="creativecommons">
                    <a href="http://creativecommons.org/licenses/by-sa/4.0/" rel="license">
                    </a>
                    <span>
                        版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。                    </span>
                    <div class="article-source-link2222">
                        本文链接：<a href="https://blog.csdn.net/mmc_maodun/article/details/13005125">https://blog.csdn.net/mmc_maodun/article/details/13005125</a>
                    </div>
                </span>
                    
                </div>
                                                    <!--一个博主专栏付费入口-->
             
             <!--一个博主专栏付费入口结束-->
            <link href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-4a3473df85.css" rel="stylesheet">
                                        <link href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-4a3473df85.css" rel="stylesheet">
                <div class="htmledit_views" id="content_views">
                                            
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><strong><span style="color: rgb(136, 0, 0);">转载请注明出处：</span><a href="http://blog.csdn.net/ns_code/article/details/13005125" rel="nofollow"><span style="color: rgb(0, 0, 153);">http://blog.csdn.net/ns_code/article/details/13005125</span></a></strong></span></span></p>
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><br></span></span></span></span></p>
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);">&nbsp; &nbsp; 还记得上篇提到的setPreviewCallback(Camera.PreviewCallback cb)函数吗？我们在开始预览帧视频之前，调用的它，这里要注意其内部的<span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);">Camera.PreviewCallback</span></span></span></span>类型的参数，我们需要写一个类继承Camera.PreviewCallback的类，在该类中覆写public
 void onPreviewFrame(byte[] data, Camera camera)方法，这里的data参数保存的即是预览帧是视频数据，一旦程序调用<span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);">Camera.PreviewCallback</span></span></span></span></span></span></span></span>接口，便会自动调用发方法，因此当我们在开始预览帧视频之前调用</span></span></span></span><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);">setPreviewCallback(Camera.PreviewCallback
 cb)函数时，便会回调该方法，理论上来说我们在这个方法中写发送帧视频的代码就行了，但实际上我们并不能这么做，因为发送视频数据是一个很耗时的操作，为了防止UI线程阻塞，我们需要另外开启一个线程，在该线程中实现视频的发送操作</span></span></span></span>。</p>
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp; 这里我们采用AsyncTask&lt;Void, Void, Void&gt;后台线程，因此我们需要再写一个类，继承</span></span></span></span><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);">AsyncTask&lt;Void,
 Void, Void&gt;抽象类，并覆写其中的protected Void doInBackground(Void... params)方法，在该方法中编写发送视频数据的程序即可，<span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);">这里要注意形参的含义，</span></span></span></span></span></span></span></span>因为的项目中不需要用到这三个参数，因此全部传入Void，关于<span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);">AsyncTask的详细使用，可以参见这两篇博客：<a href="http://blog.csdn.net/ns_code/article/details/12889455" rel="nofollow">http://blog.csdn.net/ns_code/article/details/12889455</a>和<a href="http://blog.csdn.net/liuhe688/article/details/6532519" rel="nofollow">http://blog.csdn.net/liuhe688/article/details/6532519</a>，我在该方法中写的代码如下：</span></span></span></span></span></span></span></span></p>
<p></p>
<pre><code class="language-java hljs"><ol class="hljs-ln"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//该方法运行在后台线程中，主要负责执行耗时的后台计算传输等工作，</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//实际的后台操作被UI Thread调用时，该方法被回调</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-meta">@Override</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-function"><span class="hljs-keyword">protected</span> Void <span class="hljs-title">doInBackground</span><span class="hljs-params">(Void... params)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-comment">//cam = (CameraActivity)context;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	Size size = cam.getCamera().getParameters().getPreviewSize();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-keyword">int</span> wide = size.width;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-keyword">int</span> high = size.height;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	YuvImage image = <span class="hljs-keyword">new</span> YuvImage(data, ImageFormat.NV21, wide, high, <span class="hljs-keyword">null</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-comment">//因为要实时处理视频流，因此用内存操作流比较合适</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	ByteArrayOutputStream os = <span class="hljs-keyword">new</span> ByteArrayOutputStream(data.length);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">if</span>(!image.compressToJpeg(<span class="hljs-keyword">new</span> Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, wide, high), <span class="hljs-number">100</span>, os)){</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    send(os);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li></ol></code></pre><br><p><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"></span></span></span></span></span></span></span></span></p>
<p><span><span><span>&nbsp;&nbsp;&nbsp; <span style="font-size: 18px;">
<span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span><span><span>这里倒数第三行的send（os）记为发送视频的操作，当然，如果你是做其他的操作，而不是传输视频数据，你也可以将其改为其他的函数，比如做街景检测、人脸车牌识别等，而其他代码基本不用修改，发送视频的send方法基本就是按照TCP协议编写，在JAVA中是用Socket类编写客户端的代码：<span><span><span><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span><span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span><span><span><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span><span><span><span><span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<pre><code class="language-java hljs"><ol class="hljs-ln" style="width: 798px;"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//发送视频流到PC端,这里传递过来的参数os中保存的是视频输出流数据</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ByteArrayOutputStream os)</span> </span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-comment">//定义用来保存从输入流中读取的视频流数据的byte数组</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	<span class="hljs-keyword">try</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		Socket client = <span class="hljs-keyword">new</span> Socket(ipName,<span class="hljs-number">30000</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		OutputStream outSocket = client.getOutputStream();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		<span class="hljs-comment">//实例化内存输入流，将视频流数据写入到内存中</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		ByteArrayInputStream inputFromOs = <span class="hljs-keyword">new</span> ByteArrayInputStream(os.toByteArray());</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		<span class="hljs-comment">//不断从内存中读取数据到buffer中，不断再从buffer中将视频数据发送到outSocket流中</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		<span class="hljs-keyword">int</span> amount;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		<span class="hljs-keyword">while</span>((amount =inputFromOs.read(buffer) ) != -<span class="hljs-number">1</span>)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">			outSocket.write(buffer, <span class="hljs-number">0</span>, amount);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		<span class="hljs-comment">//这里需要刷新用到缓冲区的输出流</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		os.flush();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		inputFromOs.close();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		os.close();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		outSocket.close();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	} <span class="hljs-keyword">catch</span> (UnknownHostException e) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		e.printStackTrace();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		System.out.println(<span class="hljs-string">"无法找到要连接的服务器"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	} <span class="hljs-keyword">catch</span> (IOException e) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		e.printStackTrace();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">		System.out.println(<span class="hljs-string">"IO错误"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">	}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}	</div></div></li></ol></code></pre>
<p></p>
<span><span><span><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span><span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<p></p>
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span><span><span></span></span></span></span></span></span></span></span></span></span></span></p>
<span><span><span><span><span><span><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span><span><span><span><span><span><span><span><span>最后，什么时候调用protected
 Void doInBackground(Void... params)方法呢？看了上面那两篇博客，应该也会明白了，当调用execute(Params... params)方法时，便会自动回调该方法，从而执行其内部代码。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>
<p></p>
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span><span><span><br></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span style="font-size: 18px;"><span style="font-size: 18px;"><span style="color: rgb(136, 0, 0);"><span style="color: rgb(0, 0, 0);"><span><span><span>至此，整个项目的Android客户端代码已经编写完毕，下篇将讲述PC端（亦即服务端）代码的实现</span></span></span><br></span></span></span></span></span></span></span></span></p>
                                    </div>
                    </div>


</div>


</body></html>