<html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Android 操作系统架构开篇</title>
  <link href="images/style.css" rel="stylesheet">
</head>

<body class="stackedit"><div class="stackedit__html">

<article>
    <div class="container" style="overflow: hidden;">
        <div class="row">

    <!-- Post Container -->
            <div class="&#10;                col-lg-8 col-lg-offset-2&#10;                col-md-10 col-md-offset-1&#10;                post-container">

								<blockquote>
  <p><strong>版权声明：</strong> 本站所有博文内容均为原创，转载请务必注明作者与原文链接，且不得篡改原文内容。</p>
</blockquote>

<p>为便于日常查阅本博客，可通过 <strong><a href="http://gityuan.com/archive/">Gityuan博客导航</a></strong> 方便检索文章</p>

<h3 id="一引言">一、引言<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 一引言" href="#一引言" data-anchorjs-icon="#"></a></h3>

<p>众所周知，Android是谷歌开发的一款基于Linux的开源操作系统，从诞生至今已有10余年，这一路走来Android遇到哪些问题？大版本升级朝着什么方向演进？Android的未来如何？我的公号<a href="https://mp.weixin.qq.com/s/W38aauoCEEUbL8KvUkb_Rw">《Android 技术架构演进与未来》</a> 讲解了Android一路走来，在用户体验、性能、功耗、安全、隐私等方面取得的很大进步，以及未来可能的方向。</p>

<p>本文作为Android系统架构的开篇，起到提纲挈领的作用，从系统整体架构角度概要讲解Android系统的核心技术点，带领大家初探Android系统全貌以及内部运作机制。虽然Android系统非常庞大且错综复杂，需要具备全面的技术栈，但整体架构设计清晰。Android底层内核空间以Linux Kernel作为基石，上层用户空间由Native系统库、虚拟机运行环境、框架层组成，通过系统调用(Syscall)连通系统的内核空间与用户空间。对于用户空间主要采用C++和Java代码编写，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而连通整个系统。</p>

<p>为了能让大家整体上大致了解Android系统涉及的知识层面，先来看一张Google官方提供的经典分层架构图，从下往上依次分为Linux内核、HAL、系统Native库和Android运行时环境、Java框架层以及应用层这5层架构，其中每一层都包含大量的子模块或子系统。</p>

<p><img alt="android-stack" src="images/android05601.png"></p>

<p>上图采用静态分层方式的架构划分，众所周知，程序代码是死的，系统运转是活的，各模块代码运行在不同的进程(线程)中，相互之间进行着各种错终复杂的信息传递与交互流，从这个角度来说此图并没能体现Android整个系统的内部架构、运行机理，以及各个模块之间是如何衔接与配合工作的。</p>

<p><strong>为了更深入地掌握Android整个架构思想以及各个模块在Android系统所处的地位与价值，计划以Android系统启动过程为主线，以进程的视角来诠释Android M系统全貌</strong>，全方位的深度剖析各个模块功能，争取各个击破。这样才能犹如庖丁解牛，解决、分析问题则能游刃有余。</p>

<h3 id="二android架构">二、Android架构<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 二android架构" href="#二android架构" data-anchorjs-icon="#"></a></h3>

<p>Google提供的5层架构图很经典，但为了更进一步透视Android系统架构，本文更多的是以进程的视角，以分层的架构来诠释Android系统的全貌，阐述Android内部的环环相扣的内在联系。</p>

<p><strong>系统启动架构图</strong></p>

<p>点击查看<a href="http://gityuan.com/images/android-arch/android-boot.jpg">大图</a></p>

<p><img alt="process_status" src="images/android05602.jpg"></p>

<p><strong>图解：</strong>
Android系统启动过程由上图从下往上的一个过程是由Boot Loader引导开机，然后依次进入 -&gt; <code class="language-plaintext highlighter-rouge">Kernel</code> -&gt; <code class="language-plaintext highlighter-rouge">Native</code> -&gt; <code class="language-plaintext highlighter-rouge">Framework</code> -&gt; <code class="language-plaintext highlighter-rouge">App</code>，接来下简要说说每个过程：</p>

<p>关于Loader层：</p>

<ul>
  <li>Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在<code class="language-plaintext highlighter-rouge">ROM</code>里的预设代码开始执行，然后加载引导程序到<code class="language-plaintext highlighter-rouge">RAM</code>；</li>
  <li>Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。</li>
</ul>

<h4 id="21-linux内核层">2.1 Linux内核层<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 21 linux内核层" href="#21-linux内核层" data-anchorjs-icon="#"></a></h4>
<p>Android平台的基础是Linux内核，比如ART虚拟机最终调用底层Linux内核来执行功能。Linux内核的安全机制为Android提供相应的保障，也允许设备制造商为内核开发硬件驱动程序。</p>

<ul>
  <li>启动Kernel的swapper进程(pid=0)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作；</li>
  <li>启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。<code class="language-plaintext highlighter-rouge">kthreadd进程是所有内核进程的鼻祖</code>。</li>
</ul>

<h4 id="22-硬件抽象层-hal">2.2 硬件抽象层 (HAL)<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 22 硬件抽象层 hal" href="#22-硬件抽象层-hal" data-anchorjs-icon="#"></a></h4>
<p>硬件抽象层 (HAL) 提供标准接口，HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一组接口，比如WIFI/蓝牙模块，当框架API请求访问设备硬件时，Android系统将为该硬件加载相应的库模块。</p>

<h4 id="23-android-runtime--系统库">2.3 Android Runtime &amp; 系统库<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 23 android runtime  系统库" href="#23-android-runtime--系统库" data-anchorjs-icon="#"></a></h4>

<p>每个应用都在其自己的进程中运行，都有自己的虚拟机实例。ART通过执行DEX文件可在设备运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式文件，经过优化，使用内存很少。ART主要功能包括：预先(AOT)和即时(JIT)编译，优化的垃圾回收(GC)，以及调试相关的支持。</p>

<p>这里的Native系统库主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid=1),是Linux系统的用户进程，<code class="language-plaintext highlighter-rouge">init进程是所有用户进程的鼻祖</code>。</p>

<ul>
  <li>init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程；</li>
  <li>init进程还启动<code class="language-plaintext highlighter-rouge">servicemanager</code>(binder服务管家)、<code class="language-plaintext highlighter-rouge">bootanim</code>(开机动画)等重要服务</li>
  <li>init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，<code class="language-plaintext highlighter-rouge">Zygote是所有Java进程的父进程</code>，Zygote进程本身是由init进程孵化而来的。</li>
</ul>

<h4 id="24-framework层">2.4 Framework层<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 24 framework层" href="#24-framework层" data-anchorjs-icon="#"></a></h4>

<ul>
  <li>Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含：
    <ul>
      <li>加载ZygoteInit类，注册Zygote Socket服务端套接字</li>
      <li>加载虚拟机</li>
      <li>提前加载类preloadClasses</li>
      <li>提前加载资源preloadResouces</li>
    </ul>
  </li>
  <li>System Server进程，是由Zygote进程fork而来，<code class="language-plaintext highlighter-rouge">System Server是Zygote孵化的第一个进程</code>，System Server负责启动和管理整个Java framework，包含ActivityManager，WindowManager，PackageManager，PowerManager等服务。</li>
  <li>Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。</li>
</ul>

<h4 id="25-app层">2.5 App层<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 25 app层" href="#25-app层" data-anchorjs-icon="#"></a></h4>

<ul>
  <li>Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App；</li>
  <li>Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。</li>
  <li>所有的App进程都是由Zygote进程fork生成的。</li>
</ul>

<h4 id="26-syscall--jni">2.6 Syscall &amp;&amp; JNI<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 26 syscall  jni" href="#26-syscall--jni" data-anchorjs-icon="#"></a></h4>

<ul>
  <li>Native与Kernel之间有一层系统调用(SysCall)层，见<a href="http://gityuan.com/2016/05/21/syscall/">Linux系统调用(Syscall)原理</a>;</li>
  <li>Java层与Native(C/C++)层之间的纽带JNI，见<a href="http://gityuan.com/2016/05/28/android-jni/">Android JNI原理分析</a>。</li>
</ul>

<h3 id="三通信方式">三、通信方式<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 三通信方式" href="#三通信方式" data-anchorjs-icon="#"></a></h3>

<p>无论是Android系统，还是各种Linux衍生系统，各个组件、模块往往运行在各种不同的进程和线程内，这里就必然涉及进程/线程之间的通信。对于IPC(Inter-Process Communication, 进程间通信)，Linux现有管道、消息队列、共享内存、套接字、信号量、信号这些IPC机制，Android额外还有Binder IPC机制，Android OS中的Zygote进程的IPC采用的是Socket机制，在上层system server、media server以及上层App之间更多的是采用Binder IPC方式来完成跨进程间的通信。对于Android上层架构中，很多时候是在同一个进程的线程之间需要相互通信，例如同一个进程的主线程与工作线程之间的通信，往往采用的Handler消息机制。</p>

<p>想深入理解Android内核层架构，必须先深入理解Linux现有的IPC机制；对于Android上层架构，则最常用的通信方式是Binder、Socket、Handler，当然也有少量其他的IPC方式，比如杀进程Process.killProcess()采用的是signal方式。下面说说Binder、Socket、Handler：</p>

<h4 id="31-binder">3.1 Binder<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 31 binder" href="#31-binder" data-anchorjs-icon="#"></a></h4>

<p>Binder作为Android系统提供的一种IPC机制，无论从系统开发还是应用开发，都是Android系统中最重要的组成，也是最难理解的一块知识点，想了解<a href="https://www.zhihu.com/question/39440766/answer/89210950">为什么Android要采用Binder作为IPC机制？</a> 可查看我在知乎上的回答。深入了解Binder机制，最好的方法便是阅读源码，借用Linux鼻祖Linus Torvalds曾说过的一句话：Read The Fucking Source Code。下面简要说说Binder IPC原理。</p>

<p><strong>Binder IPC原理</strong></p>

<p>Binder通信采用c/s架构，从组件视角来说，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。</p>

<p><img alt="ServiceManager" src="images/android05603.jpg"></p>

<ul>
  <li>想进一步了解Binder，可查看<a href="http://gityuan.com/2015/10/31/binder-prepare/">Binder系列—开篇</a>，Binder系列花费了13篇文章的篇幅，从源码角度出发来讲述Driver、Native、Framework、App四个层面的整个完整流程。根据有些读者反馈这个系列还是不好理解，这个binder涉及的层次跨度比较大，知识量比较广，建议大家先知道binder是用于进程间通信，有个大致概念就可以先去学习系统基本知识，等后面有一定功力再进一步深入研究Binder机制。</li>
</ul>

<p><strong>Binder原理篇</strong></p>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>序号</th>
      <th>文章名</th>
      <th>概述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0</td>
      <td><a href="http://gityuan.com/2015/10/31/binder-prepare/">Binder系列—开篇</a></td>
      <td>Binder概述</td>
    </tr>
    <tr>
      <td>1</td>
      <td><a href="http://gityuan.com/2015/11/07/binder-start-sm/">Binder系列3—启动Service Manager</a></td>
      <td>ServiceManager守护进程 注册和查询服务</td>
    </tr>
    <tr>
      <td>2</td>
      <td><a href="http://gityuan.com/2015/11/08/binder-get-sm/">Binder系列4—获取Service Manager</a></td>
      <td>获取代理对象BpServiceManager</td>
    </tr>
    <tr>
      <td>3</td>
      <td><a href="http://gityuan.com/2015/11/14/binder-add-service/">Binder系列5—注册服务(addService)</a></td>
      <td>注册Media服务</td>
    </tr>
    <tr>
      <td>4</td>
      <td><a href="http://gityuan.com/2015/11/15/binder-get-service/">Binder系列6—获取服务(getService)</a></td>
      <td>获取Media代理，以及DeathRecipient</td>
    </tr>
    <tr>
      <td>5</td>
      <td><a href="http://gityuan.com/2015/11/21/binder-framework/">Binder系列7—framework层分析</a></td>
      <td>framework层服务注册和查询，Binder注册</td>
    </tr>
    <tr>
      <td>6</td>
      <td><a href="http://gityuan.com/2016/10/29/binder-thread-pool/">理解Binder线程池的管理</a></td>
      <td>Binder的startThreadPool过程</td>
    </tr>
    <tr>
      <td>7</td>
      <td><a href="http://gityuan.com/2016/09/04/binder-start-service/">彻底理解Android Binder通信架构</a></td>
      <td>startService为主线</td>
    </tr>
    <tr>
      <td>8</td>
      <td><a href="http://gityuan.com/2015/11/28/binder-summary/">Binder系列10—总结</a></td>
      <td>Binder的简单总结</td>
    </tr>
    <tr>
      <td>9</td>
      <td><a href="http://gityuan.com/2016/03/05/binder-clearCallingIdentity/">Binder IPC的权限控制</a></td>
      <td>clearCallingIdentity/restoreCallingIdentity</td>
    </tr>
    <tr>
      <td>10</td>
      <td><a href="http://gityuan.com/2016/10/03/binder_linktodeath/">Binder死亡通知机制之linkToDeath</a></td>
      <td>Binder死亡通知机制</td>
    </tr>
  </tbody>
</table></div>

<p><strong>Binder驱动篇:</strong></p>

<div class="table-responsive"><table class="table">
  <tbody>
    <tr>
      <td>1</td>
      <td><a href="http://gityuan.com/2015/11/01/binder-driver/">Binder系列1—Binder Driver初探</a></td>
      <td>驱动open/mmap/ioctl，以及binder结构体</td>
    </tr>
    <tr>
      <td>2</td>
      <td><a href="http://gityuan.com/2015/11/02/binder-driver-2/">Binder系列2—Binder Driver再探</a></td>
      <td>Binder通信协议，内存机制</td>
    </tr>
  </tbody>
</table></div>

<p><strong>Binder使用篇:</strong></p>

<div class="table-responsive"><table class="table">
  <tbody>
    <tr>
      <td>1</td>
      <td><a href="http://gityuan.com/2015/11/22/binder-use/">Binder系列8—如何使用Binder</a></td>
      <td>Native层、Framwrok层自定义Binder服务</td>
    </tr>
    <tr>
      <td>2</td>
      <td><a href="http://gityuan.com/2015/11/23/binder-aidl/">Binder系列9—如何使用AIDL</a></td>
      <td>App层自定义Binder服务</td>
    </tr>
  </tbody>
</table></div>

<h4 id="32-socket">3.2 Socket<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 32 socket" href="#32-socket" data-anchorjs-icon="#"></a></h4>

<p>Socket通信方式也是C/S架构，比Binder简单很多。在Android系统中采用Socket通信方式的主要有：</p>

<ul>
  <li>zygote：用于孵化进程，system_server创建进程是通过socket向zygote进程发起请求；</li>
  <li>installd：用于安装App的守护进程，上层PackageManagerService很多实现最终都是交给它来完成；</li>
  <li>lmkd：lowmemorykiller的守护进程，Java层的LowMemoryKiller最终都是由lmkd来完成；</li>
  <li>adbd：这个也不用说，用于服务adb；</li>
  <li>logcatd:这个不用说，用于服务logcat；</li>
  <li>vold：即volume Daemon，是存储类的守护进程，用于负责如USB、Sdcard等存储设备的事件处理。</li>
</ul>

<p>等等还有很多，这里不一一列举，Socket方式更多的用于Android framework层与native层之间的通信。Socket通信方式相对于binder比较简单，这里省略。</p>

<h4 id="33-handler">3.3 Handler<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 33 handler" href="#33-handler" data-anchorjs-icon="#"></a></h4>

<p><strong>Binder/Socket用于进程间通信，而Handler消息机制用于同进程的线程间通信</strong>，Handler消息机制是由一组MessageQueue、Message、Looper、Handler共同组成的，为了方便且称之为Handler消息机制。</p>

<p>有人可能会疑惑，为何Binder/Socket用于进程间通信，能否用于线程间通信呢？答案是肯定，对于两个具有独立地址空间的进程通信都可以，当然也能用于共享内存空间的两个线程间通信，这就好比杀鸡用牛刀。接着可能还有人会疑惑，那handler消息机制能否用于进程间通信？答案是不能，Handler只能用于共享内存地址空间的两个线程间通信，即同进程的两个线程间通信。很多时候，Handler是工作线程向UI主线程发送消息，即App应用中只有主线程能更新UI，其他工作线程往往是完成相应工作后，通过Handler告知主线程需要做出相应地UI更新操作，Handler分发相应的消息给UI主线程去完成，如下图：</p>

<p><img alt="handler_communication" src="images/android05604.jpg"></p>

<p>由于工作线程与主线程共享地址空间，即Handler实例对象mHandler位于线程间共享的内存堆上，工作线程与主线程都能直接使用该对象，只需要注意多线程的同步问题。工作线程通过mHandler向其成员变量MessageQueue中添加新Message，主线程一直处于loop()方法内，当收到新的Message时按照一定规则分发给相应的handleMessage()方法来处理。所以说，Handler消息机制用于同进程的线程间通信，其核心是线程间共享内存空间，而不同进程拥有不同的地址空间，也就不能用handler来实现进程间通信。</p>

<p>上图只是Handler消息机制的一种处理流程，是不是只能工作线程向UI主线程发消息呢，其实不然，可以是UI线程向工作线程发送消息，也可以是多个工作线程之间通过handler发送消息。更多关于Handler消息机制文章：</p>

<ul>
  <li><a href="http://gityuan.com/2015/12/26/handler-message-framework/">Android消息机制-Handler(framework篇)</a></li>
  <li><a href="http://gityuan.com/2015/12/27/handler-message-native/">Android消息机制-Handler(native篇)</a></li>
  <li><a href="http://gityuan.com/2016/01/01/handler-message-usage/">Android消息机制3-Handler(实战)</a></li>
</ul>

<p>要理解framework层源码，掌握这3种基本的进程/线程间通信方式是非常有必要，当然Linux还有不少其他的IPC机制，比如共享内存、信号、信号量，在源码中也有体现，如果想全面彻底地掌握Android系统，还是需要对每一种IPC机制都有所了解。</p>

<h3 id="四核心提纲">四、核心提纲<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 四核心提纲" href="#四核心提纲" data-anchorjs-icon="#"></a></h3>

<p>博主对于Android从系统底层一路到上层都有自己的理解和沉淀，通过前面对系统启动的介绍，相信大家对Android系统有了一个整体观。接下来需抓核心、理思路，争取各个击破。后续将持续更新和完善整个大纲，不限于进程、内存、IO、系统服务架构以及分析实战等文章。</p>

<p>当然本站有一些文章没来得及进一步加工，有时间根据大家的反馈，不断修正和完善所有文章，争取给文章，再进一步精简非核心代码，增加可视化图表以及文字的结论性分析。基于<strong>Android 6.0的源码</strong>，专注于分享Android系统原理、架构分析的原创文章。</p>

<p><strong>建议阅读群体</strong>： 适合于正从事或者有兴趣研究Android系统的工程师或者技术爱好者，也适合Android App高级工程师；对于尚未入门或者刚入门的App工程师阅读可能会有点困难，建议先阅读更基础的资料，再来阅读本站博客。</p>

<p>看到Android整个系统架构是如此庞大的, 该问如何学习Android系统, 以下是我自己的Android的学习和研究论，仅供参考<a href="http://gityuan.com/2016/04/24/how-to-study-android/">如何自学Android</a>。</p>

<p>从整理上来列举一下Android系统的核心知识点概览：</p>

<p><img alt="Android_os" src="images/android05605.png"></p>

<h4 id="41-系统启动系列">4.1 系统启动系列<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 41 系统启动系列" href="#41-系统启动系列" data-anchorjs-icon="#"></a></h4>

<p><img alt="android-booting" src="images/android05606.jpg"></p>

<p><a href="http://gityuan.com/2016/02/01/android-booting/">Android系统启动-概述</a>:
Android系统中极其重要进程：init, zygote, system_server, servicemanager 进程:</p>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>序号</th>
      <th>进程启动</th>
      <th>概述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><a href="http://gityuan.com/2016/02/05/android-init/">init进程</a></td>
      <td>Linux系统中用户空间的第一个进程, Init.main</td>
    </tr>
    <tr>
      <td>2</td>
      <td><a href="http://gityuan.com/2016/02/13/android-zygote/">zygote进程</a></td>
      <td>所有Ａpp进程的父进程, ZygoteInit.main</td>
    </tr>
    <tr>
      <td>3</td>
      <td><a href="http://gityuan.com/2016/02/14/android-system-server/">system_server进程(上篇)</a></td>
      <td>系统各大服务的载体, forkSystemServer过程</td>
    </tr>
    <tr>
      <td>4</td>
      <td><a href="http://gityuan.com/2016/02/20/android-system-server-2/">system_server进程(下篇)</a></td>
      <td>系统各大服务的载体, SystemServer.main</td>
    </tr>
    <tr>
      <td>5</td>
      <td><a href="http://gityuan.com/2015/11/07/binder-start-sm/">servicemanager进程</a></td>
      <td>binder服务的大管家, 守护进程循环运行在binder_loop</td>
    </tr>
    <tr>
      <td>6</td>
      <td><a href="http://gityuan.com/2016/03/26/app-process-create/">app进程</a></td>
      <td>通过Process.start启动App进程, ActivityThread.main</td>
    </tr>
  </tbody>
</table></div>

<p>再来看看守护进程(也就是进程名一般以d为后缀，比如logd，此处d是指daemon的简称), 下面介绍部分守护进程：</p>

<ul>
  <li><a href="http://gityuan.com/2016/06/15/android-debuggerd/">debuggerd</a></li>
  <li><a href="http://gityuan.com/2016/11/13/android-installd">installd</a></li>
  <li><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/">lmkd</a></li>
  <li><a href="http://gityuan.com/2018/01/27/android-log/">logd</a></li>
</ul>

<h4 id="42-系统稳定性系列">4.2 系统稳定性系列<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 42 系统稳定性系列" href="#42-系统稳定性系列" data-anchorjs-icon="#"></a></h4>

<p><a href="http://gityuan.com/2016/06/19/stability_summary/">Android系统稳定性</a>主要是异常崩溃(crash)和执行超时(timeout),:</p>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>序号</th>
      <th>文章名</th>
      <th>概述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><a href="http://gityuan.com/2016/07/02/android-anr/">理解Android ANR的触发原理</a></td>
      <td>触发ANR的场景以及机理</td>
    </tr>
    <tr>
      <td>2</td>
      <td><a href="http://gityuan.com/2017/01/01/input-anr/">Input系统—ANR原理分析</a></td>
      <td>input触发ANR的原理</td>
    </tr>
    <tr>
      <td>3</td>
      <td><a href="http://gityuan.com/2016/12/02/app-not-response/">理解Android ANR的信息收集过程</a></td>
      <td>AMS.appNotResponding过程分析,收集traces</td>
    </tr>
    <tr>
      <td>4</td>
      <td><a href="http://gityuan.com/2016/11/26/art-trace/">解读Java进程的Trace文件</a></td>
      <td>kill -3 信息收集过程</td>
    </tr>
    <tr>
      <td>5</td>
      <td><a href="http://gityuan.com/2016/11/27/native-traces/">Native进程之Trace原理</a></td>
      <td>debuggerd -b 信息收集过程</td>
    </tr>
    <tr>
      <td>6</td>
      <td><a href="http://gityuan.com/2016/06/21/watchdog/">WatchDog工作原理</a></td>
      <td>WatchDog触发机制</td>
    </tr>
    <tr>
      <td>7</td>
      <td><a href="http://gityuan.com/2016/06/24/app-crash/">理解Java   Crash处理流程</a></td>
      <td>AMS.handleApplicationCrash过程分析</td>
    </tr>
    <tr>
      <td>8</td>
      <td><a href="http://gityuan.com/2016/06/25/android-native-crash/">理解Native Crash处理流程</a></td>
      <td>debuggerd守护进程</td>
    </tr>
    <tr>
      <td>9</td>
      <td><a href="http://gityuan.com/2019/01/19/global_ref/">global reference限制策略</a></td>
      <td>global reference</td>
    </tr>
  </tbody>
</table></div>

<h4 id="43-android进程系列">4.3 Android进程系列<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 43 android进程系列" href="#43-android进程系列" data-anchorjs-icon="#"></a></h4>
<p>进程/线程是操作系统的魂，各种服务、组件、子系统都是依附于具体的进程实体。深入理解进程机制对于掌握Android系统整体架构和运转机制是非常有必要的，是系统工程师的基本功，下面列举进程相关的文章：</p>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>序号</th>
      <th>文章名</th>
      <th>概述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><a href="http://gityuan.com/2016/03/26/app-process-create/">理解Android进程创建流程</a></td>
      <td>Process.start过程分析</td>
    </tr>
    <tr>
      <td>2</td>
      <td><a href="http://gityuan.com/2016/04/16/kill-signal/">理解杀进程的实现原理</a></td>
      <td>Process.killProcess过程分析</td>
    </tr>
    <tr>
      <td>3</td>
      <td><a href="http://gityuan.com/2016/10/09/app-process-create-2/">Android四大组件与进程启动的关系</a></td>
      <td>AMS.startProcessLocked过程分析组件与进程</td>
    </tr>
    <tr>
      <td>4</td>
      <td><a href="http://gityuan.com/2016/10/22/force-stop/">Android进程绝杀技–forceStop</a></td>
      <td>force-stop过程分析彻底移除组件与杀进程</td>
    </tr>
    <tr>
      <td>5</td>
      <td><a href="http://gityuan.com/2016/09/24/android-thread/">理解Android线程创建流程</a></td>
      <td>3种不同线程的创建过程</td>
    </tr>
    <tr>
      <td>6</td>
      <td><a href="http://gityuan.com/2016/09/04/binder-start-service/">彻底理解Android Binder通信架构</a></td>
      <td>以start-service为线,阐述进程间通信机理</td>
    </tr>
    <tr>
      <td>7</td>
      <td><a href="http://gityuan.com/2016/10/29/binder-thread-pool/">理解Binder线程池的管理</a></td>
      <td>Zygote fork的进程都默认开启binder线程池</td>
    </tr>
    <tr>
      <td>8</td>
      <td><a href="http://gityuan.com/2015/10/01/process-lifecycle/">Android进程生命周期与ADJ</a></td>
      <td>进程adj, processState以及lmk</td>
    </tr>
    <tr>
      <td>9</td>
      <td><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/">Android LowMemoryKiller原理分析</a></td>
      <td>lmk原理分析</td>
    </tr>
    <tr>
      <td>10</td>
      <td><a href="http://gityuan.com/2015/10/01/process-priority/">进程优先级</a></td>
      <td>进程nice,thread priority以及scheduler</td>
    </tr>
    <tr>
      <td>11</td>
      <td><a href="http://gityuan.com/2016/08/07/android-adj/">Android进程调度之adj算法</a></td>
      <td>updateOomAdjLocked过程</td>
    </tr>
    <tr>
      <td>12</td>
      <td><a href="http://gityuan.com/2015/12/19/android-process-category/">Android进程整理</a></td>
      <td>整理系统的所有进程/线程</td>
    </tr>
    <tr>
      <td>13</td>
      <td><a href="http://gityuan.com/2018/05/19/android-process-adj/">解读Android进程优先级ADJ算法</a></td>
      <td>Android进程ADJ优先级</td>
    </tr>
  </tbody>
</table></div>

<h4 id="44-四大组件系列">4.4 四大组件系列<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 44 四大组件系列" href="#44-四大组件系列" data-anchorjs-icon="#"></a></h4>
<p>对于App来说，Android应用的四大组件Activity，Service，Broadcast Receiver， Content Provider最为核心，接下分别展开介绍：</p>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>序号</th>
      <th>文章名</th>
      <th>类别</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><a href="http://gityuan.com/2016/03/12/start-activity/">startActivity启动过程分析</a></td>
      <td>Activity</td>
    </tr>
    <tr>
      <td>2</td>
      <td><a href="http://gityuan.com/2016/03/18/start-activity-cycle/">简述Activity生命周期</a></td>
      <td>Activity</td>
    </tr>
    <tr>
      <td>3</td>
      <td><a href="http://gityuan.com/2016/03/06/start-service/">startService启动过程分析</a></td>
      <td>Service</td>
    </tr>
    <tr>
      <td>4</td>
      <td><a href="http://gityuan.com/2016/05/01/bind-service/">bindService启动过程分析</a></td>
      <td>Service</td>
    </tr>
    <tr>
      <td>5</td>
      <td><a href="http://gityuan.com/2016/09/04/binder-start-service/">以Binder视角来看Service启动</a></td>
      <td>Service</td>
    </tr>
    <tr>
      <td>6</td>
      <td><a href="http://gityuan.com/2016/06/04/broadcast-receiver/">Android Broadcast广播机制分析</a></td>
      <td>Broadcast</td>
    </tr>
    <tr>
      <td>7</td>
      <td><a href="http://gityuan.com/2016/07/30/content-provider/">理解ContentProvider原理</a></td>
      <td>ContentProvider</td>
    </tr>
    <tr>
      <td>8</td>
      <td><a href="http://gityuan.com/2016/05/03/content_provider_release/">ContentProvider引用计数</a></td>
      <td>ContentProvider</td>
    </tr>
    <tr>
      <td>9</td>
      <td><a href="http://gityuan.com/2015/05/31/android-lifecycle/">Activity与Service生命周期</a></td>
      <td>Activity&amp;&amp;Service</td>
    </tr>
    <tr>
      <td>10</td>
      <td><a href="http://gityuan.com/2017/04/16/activity-with-window/">简述Activity与Window关系</a></td>
      <td>Activity&amp;&amp;Window</td>
    </tr>
    <tr>
      <td>11</td>
      <td><a href="http://gityuan.com/2017/05/19/ams-abstract/">四大组件之综述</a></td>
      <td>AMS</td>
    </tr>
    <tr>
      <td>12</td>
      <td><a href="http://gityuan.com/2017/05/25/service_record/">四大组件之ServiceRecord</a></td>
      <td>Service</td>
    </tr>
    <tr>
      <td>13</td>
      <td><a href="http://gityuan.com/2017/06/03/broadcast_record/">四大组件之BroadcastRecord</a></td>
      <td>Broadcast</td>
    </tr>
    <tr>
      <td>14</td>
      <td><a href="http://gityuan.com/2017/06/04/content_provider_record/">四大组件之ContentProviderRecord</a></td>
      <td>ContentProvider</td>
    </tr>
    <tr>
      <td>15</td>
      <td><a href="http://gityuan.com/2017/04/09/android_context/">理解Android Context</a></td>
      <td>Context</td>
    </tr>
    <tr>
      <td>16</td>
      <td><a href="http://gityuan.com/2017/04/02/android-application/">理解Application创建过程</a></td>
      <td>Application</td>
    </tr>
    <tr>
      <td>17</td>
      <td><a href="http://gityuan.com/2016/05/02/unbind-service/">unbindService流程分析</a></td>
      <td>Service</td>
    </tr>
    <tr>
      <td>18</td>
      <td><a href="http://gityuan.com/2017/06/11/activity_record/">四大组件之ActivityRecord</a></td>
      <td>Activity</td>
    </tr>
    <tr>
      <td>19</td>
      <td><a href="http://gityuan.com/2017/06/25/ams_summary_1/">AMS总结(一)</a></td>
      <td>AMS</td>
    </tr>
  </tbody>
</table></div>

<h4 id="45-图形系统系列">4.5 图形系统系列<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 45 图形系统系列" href="#45-图形系统系列" data-anchorjs-icon="#"></a></h4>
<p>图形也是整个系统非常复杂且重要的一个系列，涉及WindowManager,SurfaceFlinger服务。</p>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>序号</th>
      <th>文章名</th>
      <th>类别</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><a href="http://gityuan.com/2017/01/08/windowmanger/">WindowManager启动篇</a></td>
      <td>Window</td>
    </tr>
    <tr>
      <td>2</td>
      <td><a href="http://gityuan.com/2017/01/15/wms_starting_window/">WMS之启动窗口篇</a></td>
      <td>Window</td>
    </tr>
    <tr>
      <td>3</td>
      <td><a href="http://gityuan.com/2017/01/22/start-activity-wms/">以Window视角来看startActivity</a></td>
      <td>Window</td>
    </tr>
    <tr>
      <td>4</td>
      <td><a href="http://gityuan.com/2017/02/05/graphic_arch/">Android图形系统概述</a></td>
      <td>SurfaceFlinger</td>
    </tr>
    <tr>
      <td>5</td>
      <td><a href="http://gityuan.com/2017/02/11/surface_flinger/">SurfaceFlinger启动篇</a></td>
      <td>SurfaceFlinger</td>
    </tr>
    <tr>
      <td>6</td>
      <td><a href="http://gityuan.com/2017/02/18/surface_flinger_2/">SurfaceFlinger绘图篇</a></td>
      <td>SurfaceFlinger</td>
    </tr>
    <tr>
      <td>7</td>
      <td><a href="http://gityuan.com/2017/02/25/choreographer/">Choreographer原理</a></td>
      <td>Choreographer</td>
    </tr>
  </tbody>
</table></div>

<h4 id="46-系统服务篇">4.6 系统服务篇<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 46 系统服务篇" href="#46-系统服务篇" data-anchorjs-icon="#"></a></h4>
<p>再则就是在整个架构中有大量的服务，都是基于<a href="http://gityuan.com/2015/10/31/binder-prepare/">Binder</a>来交互的，<a href="http://gityuan.com/2016/10/01/system_service_common/">Android系统服务的注册过程</a>也是在此之上的构建的。计划针对部分核心服务来重点分析：</p>

<ul>
  <li>AMS服务
    <ul>
      <li><a href="http://gityuan.com/2016/02/21/activity-manager-service/">AMS启动过程（一）</a></li>
      <li>更多组件篇[见小节4.3]</li>
    </ul>
  </li>
  <li>Input系统
    <ul>
      <li><a href="http://gityuan.com/2016/12/10/input-manager/">Input系统—启动篇</a></li>
      <li><a href="http://gityuan.com/2016/12/11/input-reader/">Input系统—InputReader线程</a></li>
      <li><a href="http://gityuan.com/2016/12/17/input-dispatcher/">Input系统—InputDispatcher线程</a></li>
      <li><a href="http://gityuan.com/2016/12/24/input-ui/">Input系统—UI线程</a></li>
      <li><a href="http://gityuan.com/2016/12/31/input-ipc/">Input系统—进程交互</a></li>
      <li><a href="http://gityuan.com/2017/01/01/input-anr/">Input系统—ANR原理分析</a></li>
    </ul>
  </li>
  <li>PKMS服务
    <ul>
      <li><a href="http://gityuan.com/2016/11/06/packagemanager">PackageManager启动篇</a></li>
      <li><a href="http://gityuan.com/2016/11/13/android-installd">Installd守护进程</a></li>
    </ul>
  </li>
  <li>Alarm服务
    <ul>
      <li><a href="http://gityuan.com/2017/03/12/alarm_manager_service/">理解AlarmManager机制</a></li>
    </ul>
  </li>
  <li>JobScheduler服务
    <ul>
      <li><a href="http://gityuan.com/2017/03/10/job_scheduler_service/">理解JobScheduler机制</a></li>
    </ul>
  </li>
  <li>BatteryService
    <ul>
      <li><a href="http://gityuan.com/2016/01/10/power_rank/">Android耗电统计算法</a></li>
    </ul>
  </li>
  <li>PMS服务</li>
  <li>DropBox服务
    <ul>
      <li><a href="http://gityuan.com/2016/06/12/DropBoxManagerService/">DropBoxManager启动篇</a></li>
    </ul>
  </li>
  <li>UserManagerService
    <ul>
      <li><a href="http://gityuan.com/2016/11/20/user_manager/">多用户管理UserManager</a></li>
    </ul>
  </li>
  <li>更多系统服务</li>
</ul>

<h4 id="47-内存存储篇">4.7 内存&amp;&amp;存储篇<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 47 内存存储篇" href="#47-内存存储篇" data-anchorjs-icon="#"></a></h4>

<ul>
  <li>内存篇
    <ul>
      <li><a href="http://gityuan.com/2016/09/17/android-lowmemorykiller/">Android LowMemoryKiller原理分析</a></li>
      <li><a href="http://gityuan.com/2015/10/30/kernel-memory/">Linux内存管理</a></li>
      <li><a href="http://gityuan.com/2016/01/02/memory-analysis-command/">Android内存分析命令</a></li>
    </ul>
  </li>
  <li>存储篇
    <ul>
      <li><a href="http://gityuan.com/2016/07/17/android-io/">Android存储系统之源码篇</a></li>
      <li><a href="http://gityuan.com/2016/07/23/android-io-arch">Android存储系统之架构篇</a></li>
    </ul>
  </li>
  <li>Linux驱动篇</li>
  <li>dalvik/art
    <ul>
      <li><a href="http://gityuan.com/2016/11/26/art-trace/">解读Java进程的Trace文件</a></li>
    </ul>
  </li>
</ul>

<h4 id="48-工具篇">4.8 工具篇<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 48 工具篇" href="#48-工具篇" data-anchorjs-icon="#"></a></h4>
<p>再来说说Android相关的一些常用命令和工具以及调试手段.</p>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>序号</th>
      <th>文章名</th>
      <th>类别</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><a href="http://gityuan.com/2016/03/19/android-build/">理解Android编译命令</a></td>
      <td>build</td>
    </tr>
    <tr>
      <td>2</td>
      <td><a href="http://gityuan.com/2018/06/02/android-bp/">理解Android.bp</a></td>
      <td>build</td>
    </tr>
    <tr>
      <td>2</td>
      <td><a href="http://gityuan.com/2016/01/17/systrace/">性能工具Systrace</a></td>
      <td>systrace</td>
    </tr>
    <tr>
      <td>3</td>
      <td><a href="http://gityuan.com/2016/01/02/memory-analysis-command/">Android内存分析命令</a></td>
      <td>Memory</td>
    </tr>
    <tr>
      <td>4</td>
      <td><a href="http://gityuan.com/2015/10/11/ps-command/">ps进程命令</a></td>
      <td>Process</td>
    </tr>
    <tr>
      <td>5</td>
      <td><a href="http://gityuan.com/2016/02/27/am-command/">Am命令用法</a></td>
      <td>Am</td>
    </tr>
    <tr>
      <td>6</td>
      <td><a href="http://gityuan.com/2016/02/28/pm-command/">Pm命令用法</a></td>
      <td>Pm</td>
    </tr>
    <tr>
      <td>7</td>
      <td><a href="http://gityuan.com/2016/06/10/bugreport/">调试系列1：bugreport源码篇</a></td>
      <td>bugreport</td>
    </tr>
    <tr>
      <td>8</td>
      <td><a href="http://gityuan.com/2016/06/11/bugreport-2/">调试系列2：bugreport实战篇</a></td>
      <td>bugreport</td>
    </tr>
    <tr>
      <td>9</td>
      <td><a href="http://gityuan.com/2016/05/14/dumpsys-command/">dumpsys命令用法</a></td>
      <td>dumpsys</td>
    </tr>
    <tr>
      <td>10</td>
      <td><a href="http://gityuan.com/2018/01/27/android-log/">Android logd日志原理</a></td>
      <td>logd</td>
    </tr>
    <tr>
      <td>11</td>
      <td><a href="http://gityuan.com/2017/09/09/gdb/">介绍gdb调试工具</a></td>
      <td>gdb</td>
    </tr>
    <tr>
      <td>12</td>
      <td><a href="http://gityuan.com/2017/09/02/addr2line/">介绍addr2line调试命令</a></td>
      <td>addr2line</td>
    </tr>
  </tbody>
</table></div>

<h4 id="49-实战篇">4.9 实战篇<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 49 实战篇" href="#49-实战篇" data-anchorjs-icon="#"></a></h4>
<p>下面列举处理过的部分较为典型的案例，供大家参考</p>

<div class="table-responsive"><table class="table">
  <thead>
    <tr>
      <th>序号</th>
      <th>文章名</th>
      <th>类别</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td><a href="http://gityuan.com/2018/05/12/binder-driver-bug/">Binder Driver缺陷导致定屏的案例</a></td>
      <td>binder</td>
    </tr>
    <tr>
      <td>2</td>
      <td><a href="http://gityuan.com/2019/01/13/arraymap/">深度解读ArrayMap优势与缺陷</a></td>
      <td>ArrayMap</td>
    </tr>
    <tr>
      <td>3</td>
      <td><a href="http://gityuan.com/2018/02/10/reboot-locked-method/">数组越界导致系统重启的案例</a></td>
      <td>数组越界</td>
    </tr>
    <tr>
      <td>4</td>
      <td><a href="http://gityuan.com/2018/02/03/log-fc/">一行Log引发多线程并发问题的案例</a></td>
      <td>多线程并发</td>
    </tr>
    <tr>
      <td>5</td>
      <td><a href="http://gityuan.com/2018/02/17/monkey-deadlock/">跑monkey压力测试过程的冻屏案例</a></td>
      <td>monkey冻屏</td>
    </tr>
    <tr>
      <td>6</td>
      <td><a href="http://gityuan.com/2018/02/24/process-keep-forever/">深度剖析APP保活案例</a></td>
      <td>保活</td>
    </tr>
  </tbody>
</table></div>

<h3 id="五结束语">五、结束语<a class="anchorjs-link " style="padding-left: 0.37em; opacity: 1;" aria-label="Anchor link for: 五结束语" href="#五结束语" data-anchorjs-icon="#"></a></h3>

<p>Android系统之博大精深，包括Linux内核、Native、虚拟机、Framework，通过系统调用连通内核与用户空间，通过JNI打通用户空间的Java层和Native层，通过Binder、Socket、Handler等打通跨进程、跨线程的信息交换。只有真正阅读并理解系统核心架构的设计，解决问题和设计方案才能做到心中无剑胜有剑，才能做到知其然知其所以然。当修炼到此，恭喜你对系统有了更高一个层次的理解，正如太极剑法，忘记了所有招式，也就练成了太极剑法。</p>

<p>再回过头去看看那些API，看到的将不再是一行行代码、一个个接口的调用，而是各种信息的传递与交互工作，而是背后成千上万个小蝌蚪的动态执行流。记得《侠客行》里面的龙木二岛主终其一生也无法参透太玄经，石破天却短短数日练成绝世神功，究其根源是龙木二岛主以静态视角去解读太玄经，而石破天把墙壁的图案想象成无数游动的蝌蚪，最终成就绝世神功。一言以蔽之，程序代码是死的，系统运转是活的，要以动态视角去理解系统架构。</p>

								<hr>
								<font color="#004b97"><strong>微信公众号 </strong></font>
<a href="http://gityuan.com/images/about-me/gityuan_weixin_logo.png" target="_blank">
	<font color="#f57e42"><strong>Gityuan</strong></font>
</a>

<font color="#004b97"><strong> | 微博</strong></font>
<a href="http://weibo.com/gityuan" target="_blank">
	<font color="#f57e42"><strong>weibo.com/gityuan</strong></font>
</a>

<font color="#004b97"><strong> | 博客</strong></font>
<a href="http://gityuan.com/talk/" target="_blank">
	<font color="#f57e42"><strong>留言区交流</strong></font>
</a>
<!-- <img src="/images/about-me/gityuan_weixin_logo.png" alt="gityuan">-->

                <hr>


                <ul class="pager">
                    
                    
                </ul>


                

            </div>

    <!-- Side Catalog Container -->
        
            <div class="&#10;                col-lg-2 col-lg-offset-0&#10;                visible-lg-block&#10;                sidebar-container&#10;                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5 id="catalog">
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"><li class="h3_nav active"><a href="#一引言" rel="nofollow">一、引言</a></li><li class="h3_nav"><a href="#二android架构" rel="nofollow">二、Android架构</a></li><li class="h4_nav"><a href="#21-linux内核层" rel="nofollow">2.1 Linux内核层</a></li><li class="h4_nav"><a href="#22-硬件抽象层-hal" rel="nofollow">2.2 硬件抽象层 (HAL)</a></li><li class="h4_nav"><a href="#23-android-runtime--系统库" rel="nofollow">2.3 Android Runtime &amp; 系统库</a></li><li class="h4_nav"><a href="#24-framework层" rel="nofollow">2.4 Framework层</a></li><li class="h4_nav"><a href="#25-app层" rel="nofollow">2.5 App层</a></li><li class="h4_nav"><a href="#26-syscall--jni" rel="nofollow">2.6 Syscall &amp;&amp; JNI</a></li><li class="h3_nav"><a href="#三通信方式" rel="nofollow">三、通信方式</a></li><li class="h4_nav"><a href="#31-binder" rel="nofollow">3.1 Binder</a></li><li class="h4_nav"><a href="#32-socket" rel="nofollow">3.2 Socket</a></li><li class="h4_nav"><a href="#33-handler" rel="nofollow">3.3 Handler</a></li><li class="h3_nav"><a href="#四核心提纲" rel="nofollow">四、核心提纲</a></li><li class="h4_nav"><a href="#41-系统启动系列" rel="nofollow">4.1 系统启动系列</a></li><li class="h4_nav"><a href="#42-系统稳定性系列" rel="nofollow">4.2 系统稳定性系列</a></li><li class="h4_nav"><a href="#43-android进程系列" rel="nofollow">4.3 Android进程系列</a></li><li class="h4_nav"><a href="#44-四大组件系列" rel="nofollow">4.4 四大组件系列</a></li><li class="h4_nav"><a href="#45-图形系统系列" rel="nofollow">4.5 图形系统系列</a></li><li class="h4_nav"><a href="#46-系统服务篇" rel="nofollow">4.6 系统服务篇</a></li><li class="h4_nav"><a href="#47-内存存储篇" rel="nofollow">4.7 内存&amp;&amp;存储篇</a></li><li class="h4_nav"><a href="#48-工具篇" rel="nofollow">4.8 工具篇</a></li><li class="h4_nav"><a href="#49-实战篇" rel="nofollow">4.9 实战篇</a></li><li class="h3_nav"><a href="#五结束语" rel="nofollow">五、结束语</a></li></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="&#10;                col-lg-8 col-lg-offset-2&#10;                col-md-10 col-md-offset-1&#10;                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5 id="-1"><a href="/tags/" target="_blank">标签</a></h5>
                    <div class="tags">
                      
                            <a title="android" href="/tags/#android" target="_blank" rel="153">
                                    android
                            </a>
                      
                            <a title="组件系列" href="/tags/#组件系列" target="_blank" rel="19">
                                    组件系列
                            </a>
                      
                            <a title="else" href="/tags/#else" target="_blank" rel="3">
                                    else
                            </a>
                      
                            <a title="debug" href="/tags/#debug" target="_blank" rel="19">
                                    debug
                            </a>
                      
                            <a title="权限" href="/tags/#权限" target="_blank" rel="2">
                                    权限
                            </a>
                      
                            <a title="web" href="/tags/#web" target="_blank" rel="2">
                                    web
                            </a>
                      
                            <a title="tool" href="/tags/#tool" target="_blank" rel="12">
                                    tool
                            </a>
                      
                            <a title="java" href="/tags/#java" target="_blank" rel="12">
                                    java
                            </a>
                      
                            <a title="performance" href="/tags/#performance" target="_blank" rel="4">
                                    performance
                            </a>
                      
                            <a title="app" href="/tags/#app" target="_blank" rel="2">
                                    app
                            </a>
                      
                            <a title="algorithm" href="/tags/#algorithm" target="_blank" rel="1">
                                    algorithm
                            </a>
                      
                            <a title="进程系列" href="/tags/#进程系列" target="_blank" rel="13">
                                    进程系列
                            </a>
                      
                            <a title="虚拟机" href="/tags/#虚拟机" target="_blank" rel="1">
                                    虚拟机
                            </a>
                      
                            <a title="memory" href="/tags/#memory" target="_blank" rel="5">
                                    memory
                            </a>
                      
                            <a title="jvm" href="/tags/#jvm" target="_blank" rel="5">
                                    jvm
                            </a>
                      
                            <a title="linux" href="/tags/#linux" target="_blank" rel="11">
                                    linux
                            </a>
                      
                            <a title="binder" href="/tags/#binder" target="_blank" rel="19">
                                    binder
                            </a>
                      
                            <a title="ipc" href="/tags/#ipc" target="_blank" rel="3">
                                    ipc
                            </a>
                      
                            <a title="handler" href="/tags/#handler" target="_blank" rel="3">
                                    handler
                            </a>
                      
                            <a title="process" href="/tags/#process" target="_blank" rel="6">
                                    process
                            </a>
                      
                            <a title="power" href="/tags/#power" target="_blank" rel="1">
                                    power
                            </a>
                      
                            <a title="系统启动" href="/tags/#系统启动" target="_blank" rel="6">
                                    系统启动
                            </a>
                      
                            <a title="AMS" href="/tags/#AMS" target="_blank" rel="2">
                                    AMS
                            </a>
                      
                            <a title="PMS" href="/tags/#PMS" target="_blank" rel="1">
                                    PMS
                            </a>
                      
                            <a title="自学编程" href="/tags/#自学编程" target="_blank" rel="1">
                                    自学编程
                            </a>
                      
                            <a title="stability" href="/tags/#stability" target="_blank" rel="7">
                                    stability
                            </a>
                      
                            <a title="组件" href="/tags/#组件" target="_blank" rel="3">
                                    组件
                            </a>
                      
                            <a title="art" href="/tags/#art" target="_blank" rel="2">
                                    art
                            </a>
                      
                            <a title="graphic" href="/tags/#graphic" target="_blank" rel="1">
                                    graphic
                            </a>
                      
                            <a title="NativeDebug" href="/tags/#NativeDebug" target="_blank" rel="3">
                                    NativeDebug
                            </a>
                      
                            <a title="实战案例" href="/tags/#实战案例" target="_blank" rel="7">
                                    实战案例
                            </a>
                      
                            <a title="flutter" href="/tags/#flutter" target="_blank" rel="21">
                                    flutter
                            </a>
                      
                    </div>
                </section>
                

                <!-- Friends Blog -->
                <!--
                 -->
            </div>
        </div>
    </div>
</article>

</div>


</body></html>