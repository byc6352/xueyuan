<html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NDK-JNI实战教程（二） JNI官方中文资料 - 工匠若水</title>
  <link href="images/style.css" rel="stylesheet">
</head>

<body class="stackedit"><div class="stackedit__html">

<div class="article_content clearfix" id="article_content" style="overflow: hidden;">
            <!--一个博主专栏付费入口-->
                          <!--一个博主专栏付费入口结束-->
            <link href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-833878f763.css" rel="stylesheet">
                                        <div class="markdown_views" id="content_views">
                    <!-- flowchart 箭头图标 勿删 -->
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);" stroke-linecap="round" d="M 5 0 L 0 2.5 L 5 5 Z" />
                    </svg>
                                            <p><strong>PS一句：最终还是选择CSDN来整理发表这几年的知识点，该文章平行迁移到CSDN。因为CSDN也支持MarkDown语法了，牛逼啊！</strong></p>

<p>【工匠若水 <a href="http://blog.csdn.net/yanbober" target="_blank" rel="nofollow">http://blog.csdn.net/yanbober</a>】 阅读前一篇《NDK-JNI实战教程（一） 在Android Studio运行第一个NDK程序》 <a href="http://blog.csdn.net/yanbober/article/details/45309049" target="_blank" rel="nofollow">http://blog.csdn.net/yanbober/article/details/45309049</a></p>



<h2 id="声明"><a name="t0"></a><a name="t0"></a>声明</h2>

<p>该篇文章完全引用自《JNI完全手册》完整版，用来方便查询查阅，同时作为该系列教程的基础知识。感谢原文档作者。</p>

<p>文档所依赖的版本是比较低的，但是恰恰是低版本才能更容易上手学习。文档也有些枯燥，适合开发中参考查询和粗略概况性 <br>
的浏览掌握大局使用，也是下来几篇的基础性指导文档。下来几篇不会再解释代码简单函数释义，只会说重点，遇到不懂的来 <br>
这篇文章搜索函数名即可查阅函数详情。</p>

<p><img title="" alt="这里写图片描述" src="images/android03601.jpg"></p>

<hr>

<h2 id="设计概述"><a name="t1"></a><a name="t1"></a>设计概述</h2>



<h3 id="jni接口函数和指针"><a name="t2"></a><a name="t2"></a>JNI接口函数和指针</h3>

<p>平台相关代码是通过调用JNI函数来访问Java虚拟机功能的。JNI函数可通过接口指针来获得。接口指针是指针的指针，它指向 <br>
一个指针数组，而指针数组中的每个元素又指向一个接口函数。每个接口函数都处在数组的某个预定偏移量中。下图说明了接 <br>
口指针的组织结构。</p>

<p><img title="" alt="jni" src="images/android03602.jpg"></p>

<p>JNI接口的组织类似于C++虚拟函数表或COM接口。使用接口表而不使用硬性编入的函数表的好处是使JNI名字空间与平台相关代码分开。虚拟机可以很容易地提供多个版本的JNI函数表。例如，虚拟机可支持以下两个JNI函数表：</p>

<ul>
<li>一个表对非法参数进行全面检查，适用于调试程序。</li>
<li>另一个表只进行JNI规范所要求的最小程度的检查，因此效率较高。</li>
</ul>

<p>JNI接口指针只在当前线程中有效。因此，本地方法不能将接口指针从一个线程传递到另一个线程中。实现JNI的虚拟机可将本地线程的数据分配和储存在JNI接口指针所指向的区域中。本地方法将JNI接口指针当作参数来接受。虚拟机在从相同的Java线程中对本地方法进行多次调用时，保证传递给该本地方法的接口指针是相同的。但是，一个本地方法可被不同的Java线程所调用，因此可以接受不同的JNI接口指针。</p>



<h3 id="加载和链接本地方法"><a name="t3"></a><a name="t3"></a>加载和链接本地方法</h3>

<p>对本地方法的加载通过System.loadLibrary方法实现。下例中，类初始化方法加载了一个与平台有关的本地库，在该本地库中 <br>
给出了本地方法f的定义：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering"><span class="hljs-keyword">package</span> pkg;

class Cls {
    <span class="hljs-keyword">native</span> <span class="hljs-keyword">double</span> f(<span class="hljs-keyword">int</span> i, String s);

    <span class="hljs-keyword">static</span> {
        System.loadLibrary(<span class="hljs-string">"pkg_Cls"</span>);
    }
}</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre>

<p>System.loadLibrary的参数是程序员任意选取的库名。系统按照标准的但与平台有关的处理方法将该库名转换为本地库名。例如，Solaris系统将名称pkg_Cls转换为libpkg_Cls.so，而Win32系统将相同的名称pkg_Cls转换为pkg_Cls.dll。程序员可用单个库来存放任意数量的类所需的所有本地方法，只要这些类将被相同的类加载器所加载。虚拟机在其内部为每个类加载器保护其所加载的本地库清单。提供者应该尽量选择能够避免名称冲突的本地库名。如果底层操作系统不支持动态链接，则必须事先将所有的本地方法链接到虚拟机上。这种情况下，虚拟机实际上不需要加载库即可完成System.loadLibrary调用。程序员还可调用JNI函数RegisterNatives()来注册与类关联的本地方法。在与静态链接的函数一起使用时，RegisterNatives()函数将特别有用。</p>



<h3 id="解析本地方法名"><a name="t4"></a><a name="t4"></a>解析本地方法名</h3>

<p>动态链接程序是根据项的名称来解析各项的。本地方法名由以下几部分串接而成：</p>

<ol>
<li>前缀 Java_</li>
<li>mangled 全限定的类名</li>
<li>下划线（“_”）分隔符</li>
<li>mangled 方法名</li>
<li>对于重载的本地方法，加上两个下划线（“__”），后跟mangled参数签名</li>
</ol>

<p>虚拟机将为本地库中的方法查找匹配的方法名。它首先查找短名（没有参数签名的名称），然后再查找带参数签名的长名称。只有当某个本地方法被另一个本地方法重载时程序员才有必要使用长名。但如果本地方法的名称与非本地方法的名称相同，则不会有问题。因为非本地方法（Java方法）并不放在本地库中。下例中，不必用长名来链接本地方法g，因为另一个方法g不是本地方法，因而它并不在本地库中。</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering">class Cls1 {
    <span class="hljs-keyword">int</span> g(<span class="hljs-keyword">int</span> i);
    <span class="hljs-keyword">native</span> <span class="hljs-keyword">int</span> g(<span class="hljs-keyword">double</span> d);
}</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre>

<p>我们采取简单的名字搅乱方案，以保证所有的Unicode字符都能被转换为有效的C函数名。我们用下划线（“_”）字符来代替全限定的类名中的斜杠（“/”）。由于名称或类型描述符从来不会以数字打头，我们用 _0、…、_9 来代替转义字符序列。</p>

<p>本地方法和接口API都要遵守给定平台上的库调用标准约定。例如，UNIX系统使用C调用约定，而Win32系统使用 __stdcall。</p>



<h3 id="本地方法的参数"><a name="t5"></a><a name="t5"></a>本地方法的参数</h3>

<p>JNI接口指针是本地方法的第一个参数。其类型是JNIEnv。第二个参数随本地方法是静态还是非静态而有所不同。非静态本地方法的第二个参数是对对象的引用，而静态本地方法的第二个参数是对其Java类的引用。其余的参数对应于通常Java方法的参数。本地方法调用利用返回值将结果传回调用程序中。下一章 “JNI的类型和数据结构” 将描述Java类型和C类型之间的映射。</p>

<p>代码示例说明了如何用C函数来实现本地方法f。对本地方法f的声明如下：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering"><span class="hljs-keyword">package</span> pkg;

class Cls {
    <span class="hljs-keyword">native</span> <span class="hljs-keyword">double</span> f(<span class="hljs-keyword">int</span> i, String s);
    ...
}</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li></ul></pre>

<p>具有长mangled名称Java_pkg_Cls_f_ILjava_lang_String_2的C函数实现本地方法f：</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (
    JNIEnv *env,
    <span class="hljs-comment">/* 接口指针 */</span>
    jobject obj,
    <span class="hljs-comment">/* “this”指针 */</span>
    jint i,
    <span class="hljs-comment">/* 第一个参数 */</span>
    jstring s)
    <span class="hljs-comment">/* 第二个参数 */</span>
    {
    <span class="hljs-comment">/* 取得Java字符串的C版本 */</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str = (*env)-&gt;GetStringUTFChars(env, s, <span class="hljs-number">0</span>);
    <span class="hljs-comment">/* 处理该字符串 */</span>
    ...
    <span class="hljs-comment">/* 至此完成对 str 的处理 */</span>
    (*env)-&gt;ReleaseStringUTFChars(env, s, str);
    <span class="hljs-keyword">return</span> ...
}</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li></ul></pre>

<p>注意，我们总是用接口指针env来操作Java对象。可用C++将此代码写得稍微简洁一些，如代码示例所示：</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-comment">/* 指定 C 调用约定 */</span>
    jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (
        JNIEnv *env,
        <span class="hljs-comment">/* 接口指针 */</span>
        jobject obj,
        <span class="hljs-comment">/* “this”指针 */</span>
        jint i,
        <span class="hljs-comment">/* 第一个参数 */</span>
        jstring s)
        <span class="hljs-comment">/* 第二个参数
        */</span>
        {
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *str = env-&gt;GetStringUTFChars(s, <span class="hljs-number">0</span>);
        ...
        env-&gt;ReleaseStringUTFChars(s, str);
        <span class="hljs-keyword">return</span> ...
    }</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li></ul></pre>

<p>使用C++后，源代码变得更为直接，且接口指针参数消失。但是，C++的内在机制与C的完全一样。在C++中，JNI函数被定义为内联成员函数，它们将扩展为相应的C对应函数。</p>



<h3 id="引用java对象"><a name="t6"></a><a name="t6"></a>引用Java对象</h3>

<p>基本类型（如整型、字符型等）在Java和平台相关代码之间直接进行复制。而Java对象由引用来传递。虚拟机必须跟踪传到平台相关代码中的对象，以使这些对象不会被垃圾收集器释放。反之，平台相关代码必须能用某种方式通知虚拟机它不再需要那些对象，同时，垃圾收集器必须能够移走被平台相关代码引用过的对象。</p>



<h4 id="全局和局部引用">全局和局部引用</h4>

<p>JNI将平台相关代码使用的对象引用分成两类：局部引用和全局引用。局部引用在本地方法调用期间有效，并在本地方法返回后被自动释放掉。全局引用将一直有效，直到被显式释放。对象是被作为局部引用传递给本地方法的，由JNI函数返回的所有Java对象也都是局部引用。JNI允许程序员从局部引用创建全局引用。要求Java对象的JNI函数既可接受全局引用也可接受局部引用。本地方法将局部引用或全局引用作为结果返回。</p>

<p>大多数情况下，程序员应该依靠虚拟机在本地方法返回后释放所有局部引用。但是，有时程序员必须显式释放某个局部引用。例如，考虑以下的情形：</p>

<ol>
<li><p>本地方法要访问一个大型Java对象，于是创建了对该Java对象的局部引用。然后，本地方法要在返回调用程序之前执行其它计算。对这个大型Java对象的局部引用将防止该对象被当作垃圾收集，即使在剩余的运算中并不再需要该对象。</p></li>
<li><p>本地方法创建了大量的局部引用，但这些局部引用并不是要同时使用。由于虚拟机需要一定的空间来跟踪每个局部引用，创建太多的局部引用将可能使系统耗尽内存。 例如，本地方法要在一个大型对象数组中循环，把取回的元素作为局部引用，并在每次迭代时对一个元素进行操作。每次迭代后，程序员不再需要对该数组元素的局部引用。</p></li>
</ol>

<p>JNI允许程序员在本地方法内的任何地方对局部引用进行手工删除。为确保程序员可以手工释放局部引用，JNI函数将不能创建额外的局部引用，除非是这些JNI函数要作为结果返回的引用。局部引用仅在创建它们的线程中有效。本地方法不能将局部引用从一个线程传递到另一个线程中。</p>



<h4 id="实现局部引用">实现局部引用</h4>

<p>为了实现局部引用，Java虚拟机为每个从Java到本地方法的控制转换都创建了注册服务程序。注册服务程序将不可移动的局部引用映射为Java对象，并防止这些对象被当作垃圾收集。所有传给本地方法的Java对象（包括那些作为JNI函数调用结果返回的对象）将被自动添加到注册服务程序中。本地方法返回后，注册服务程序将被删除，其中的所有项都可以被当作垃圾来收集。可用各种不同的方法来实现注册服务程序，例如，使用表、链接列表或hash表来实现。虽然引用计数可用来避免注册服务程序中有重复的项，但JNI实现不是必须检测和消除重复的项。注意，以保守方式扫描本地堆栈并不能如实地实现局部引用。平台相关代码可将局部引用储存在全局或堆数据结构中。</p>



<h3 id="访问java对象"><a name="t7"></a><a name="t7"></a>访问Java对象</h3>

<p>JNI提供了一大批用来访问全局引用和局部引用的函数。这意味着无论虚拟机在内部如何表示Java对象，相同的本地方法实现都能工作。这就是为什么JNI可被各种各样的虚拟机实现所支持的关键原因。通过不透明的引用来使用访问函数的开销比直接访问C数据结构的开销来得高。我们相信，大多数情况下，Java程序员使用本地方法是为了完成一些重要任务，此时这种接口的开销不是首要问题。</p>



<h4 id="访问基本类型数组">访问基本类型数组</h4>

<p>对于含有大量基本数据类型（如整数数组和字符串）的Java对象来说，这种开销将高得不可接受（考虑一下用于执行矢量和矩阵运算的本地方法的情形便知）。对Java数组进行迭代并且要通过函数调用取回数组的每个元素，其效率是非常低的。</p>

<p>一个解决办法是引入“钉住”概念，以使本地方法能够要求虚拟机钉住数组内容。而后，该本地方法将接受指向数值元素的直接指针。但是，这种方法包含以下两个前提：</p>

<ol>
<li>垃圾收集器必须支持钉住。</li>
<li>虚拟机必须在内存中连续存放基本类型数组。虽然大多数基本类型数组都是连续存放的，但布尔数组可以压缩或不压缩存储。因此，依赖于布尔数组确切存储方式的本地方法将是不可移植的。</li>
</ol>

<p>我们将采取折衷方法来克服上述两个问题。</p>

<p>首先，我们提供了一套函数，用于在Java数组的一部分和本地内存缓冲之间复制基本类型数组元素。这些函数只有在本地方法只需访问大型数组中的一小部分元素时才使用。</p>

<p>其次，程序员可用另一套函数来取回数组元素的受约束版本。记住，这些函数可能要求Java虚拟机分配存储空间和进行复制。虚拟机实现将决定这些函数是否真正复制该数组，如下所示：</p>

<ol>
<li>如果垃圾收集器支持钉住，且数组的布局符合本地方法的要求，则不需要进行复制。</li>
<li>否则，该数组将被复制到不可移动的内存块中（例如，复制到C堆中），并进行必要的格式转换，然后返回指向该副本的指针。</li>
</ol>

<p>最后，接口提供了一些函数，用以通知虚拟机本地方法已不再需要访问这些数组元素。当调用这些函数时，系统或者释放数组，或者在原始数组与其不可移动副本之间进行协调并将副本释放。</p>

<p>这种处理方法具有灵活性。垃圾收集器的算法可对每个给定的数组分别作出复制或钉住的决定。例如，垃圾收集器可能复制小型对象而钉住大型对象。JNI实现必须确保多个线程中运行的本地方法可同时访问同一数组。例如，JNI可以为每个被钉住的数组保留一个内部计数器，以便某个线程不会解开同时被另一个线程钉住的数组。注意，JNI不必将基本类型数组锁住以专供某个本地方法访问。同时从不同的线程对Java数组进行更新将导致不确定的结果。</p>



<h4 id="访问域和方法">访问域和方法</h4>

<p>JNI允许本地方法访问Java对象的域或调用其方法。JNI用符号名称和类型签名来识别方法和域。从名称和签名来定位域或对象的过程可分为两步。例如，为调用类cls中的f方法，平台相关代码首先要获得方法ID，如下所示：</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jmethodID mid = env-&gt;GetMethodID(cls, <span class="hljs-string">"f"</span>, <span class="hljs-string">"(ILjava/lang/String;)D"</span>);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>然后，平台相关代码可重复使用该方法ID而无须再查找该方法，如下所示：</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jdouble result = env-&gt;CallDoubleMethod(obj, mid, <span class="hljs-number">10</span>, str);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>域ID或方法ID并不能防止虚拟机卸载生成该ID的类。该类被卸载之后，该方法ID或域ID亦变成无效。因此，如果平台相关代码要长时间使用某个方法ID或域ID，则它必须确保：保留对所涉及类的活引用，或重新计算该方法ID或域ID。JNI对域ID和方法ID的内部实现并不施加任何限制。</p>



<h3 id="报告编程错误"><a name="t8"></a><a name="t8"></a>报告编程错误</h3>

<p>JNI不检查诸如传递NULL指针或非法参数类型之类的编程错误。非法的参数类型包括诸如要用Java类对象时却用了普通Java对象这样的错误。JNI不检查这些编程错误的理由如下：</p>

<ol>
<li>强迫JNI函数去检查所有可能的错误情况将降低正常（正确）的本地方法的性能。</li>
<li>在许多情况下，没有足够的运行时的类型信息可供这种检查使用。</li>
</ol>

<p>大多数C库函数对编程错误不进行防范。例如，printf()函数在接到一个无效地址时通常是引起运行错而不是返回错误代码。强迫C库函数检查所有可能的错误情况将有可能引起这种检查被重复进行–先是在用户代码中进行，然后又在库函数中再次进行。</p>

<p>程序员不得将非法指针或错误类型的参数传递给JNI函数。否则，可能产生意想不到的后果，包括可能使系统状态受损或使虚拟机崩溃。</p>



<h3 id="java异常"><a name="t9"></a><a name="t9"></a>Java异常</h3>

<p>JNI允许本地方法抛出任何Java异常。本地方法也可以处理突出的Java异常。未被处理的Java异常将被传回虚拟机中。</p>



<h4 id="异常和错误代码">异常和错误代码</h4>

<p>一些JNI函数使用Java异常机制来报告错误情况。大多数情况下，JNI函数通过返回错误代码并抛出Java异常来报告错误情况。错误代码通常是特殊的返回值（如 NULL），这种特殊的返回值在正常返回值范围之外。因此，程序员可以：快速检查上一个JNI调用所返回的值以确定是否出错，并通过调用函数ExceptionOccurred()来获得异常对象，它含有对错误情况的更详细说明。</p>

<p>在以下两种情况中，程序员需要先查出异常，然后才能检查错误代码：</p>

<ol>
<li>调用Java方法的JNI函数返回该Java方法的结果。程序员必须调用ExceptionOccurred() 以检查在执行Java方法期间可能发生的异常。</li>
<li>某些用于访问JNI数组的函数并不返回错误代码，但可能会抛出ArrayIndexOutOfBoundsException或ArrayStoreException。</li>
</ol>

<p>在所有其它情况下，返回值如果不是错误代码值就可确保没有抛出异常。</p>



<h4 id="异步异常">异步异常</h4>

<p>在多个线程的情况下，当前线程以外的其它线程可能会抛出异步异常。异步异常并不立即影响当前线程中平台相关代码的执行，直到出现下列情况：该平台相关代码调用某个有可能抛出同步异常的JNI函数，或者该平台相关代码用 ExceptionOccurred() 显式检查同步异常或异步异常。</p>

<p>注意，只有那些有可能抛出同步异常的JNI函数才检查异步异常。本地方法应在必要的地方（例如，在一个没有其它异常检查的紧密循环中）插入ExceptionOccurred() 检查以确保当前线程可在适当时间内对异步异常作出响应。</p>



<h4 id="异常的处理">异常的处理</h4>

<p>可用两种方法来处理平台相关代码中的异常：</p>

<ol>
<li>本地方法可选择立即返回，使异常在启动该本地方法调用的Java代码中抛出。</li>
<li>平台相关代码可通过调用ExceptionClear() 来清除异常，然后执行自己的异常处理代码。</li>
</ol>

<p>抛出了某个异常之后，平台相关代码必须先清除异常，然后才能进行其它的JNI调用。当有待定异常时，只有以下这些JNI函数可被安全地调用：ExceptionOccurred()、ExceptionDescribe()和ExceptionClear()。ExceptionDescribe()函数将打印有关待定异常的调试消息。</p>

<hr>



<h2 id="jni的类型和数据结构"><a name="t10"></a><a name="t10"></a>JNI的类型和数据结构</h2>

<p>本章讨论JNI如何将Java类型映射到本地C类型。</p>



<h3 id="基本类型"><a name="t11"></a><a name="t11"></a>基本类型</h3>

<p>基本类型和本地等效类型表：</p>

<div class="table-box"><table>
<thead>
<tr>
  <th>Java类型</th>
  <th align="left">本地类型</th>
  <th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
  <td>boolean</td>
  <td align="left">jboolean</td>
  <td align="left">无符号，8位</td>
</tr>
<tr>
  <td>byte</td>
  <td align="left">jbyte</td>
  <td align="left">无符号，8位</td>
</tr>
<tr>
  <td>char</td>
  <td align="left">jchar</td>
  <td align="left">无符号，16位</td>
</tr>
<tr>
  <td>short</td>
  <td align="left">jshort</td>
  <td align="left">有符号，16位</td>
</tr>
<tr>
  <td>int</td>
  <td align="left">jint</td>
  <td align="left">有符号，32位</td>
</tr>
<tr>
  <td>long</td>
  <td align="left">jlong</td>
  <td align="left">有符号，64位</td>
</tr>
<tr>
  <td>float</td>
  <td align="left">jfloat</td>
  <td align="left">32位</td>
</tr>
<tr>
  <td>double</td>
  <td align="left">jdouble</td>
  <td align="left"></td>
</tr>
<tr>
  <td>void</td>
  <td align="left">void</td>
  <td align="left">N/A</td>
</tr>
</tbody></table></div>


<p>为了使用方便，特提供以下定义：</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-preprocessor">#define JNI_FALSE 0</span>
<span class="hljs-preprocessor">#define JNI_TRUE 1</span></code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre>

<p>jsize整数类型用于描述主要指数和大小：</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">    <span class="hljs-keyword">typedef</span> jint jsize;</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>



<h3 id="引用类型"><a name="t12"></a><a name="t12"></a>引用类型</h3>

<p>JNI包含了很多对应于不同Java对象的引用类型。JNI引用类型的组织层次如图所示：</p>

<p><img title="" alt="jni" src="images/android03603.jpg"></p>

<p>在C中，所有其它JNI引用类型都被定义为与jobject一样。例如：</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">typedef</span> jobject jclass;</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>在C++中，JNI引入了虚构类以加强子类关系。例如：</p>



<pre class="prettyprint" name="code"><code class="language-c++ hljs r has-numbering">class _jobject {};
class _jclass : public _jobject {};
<span class="hljs-keyword">...</span>
typedef _jobject *jobject;
typedef _jclass *jclass;</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre>



<h3 id="域id和方法id"><a name="t13"></a><a name="t13"></a>域ID和方法ID</h3>

<p>方法ID和域ID是常规的C指针类型：</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">struct</span> _jfieldID;
<span class="hljs-comment">/*不透明结构 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> _jfieldID *jfieldID;
<span class="hljs-comment">/* 域 ID */</span>
<span class="hljs-keyword">struct</span> _jmethodID;
<span class="hljs-comment">/* 不透明结构 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> _jmethodID *jmethodID; <span class="hljs-comment">/* 方法 ID */</span></code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre>



<h3 id="值类型"><a name="t14"></a><a name="t14"></a>值类型</h3>

<p>jvalue联合类型在参数数组中用作单元类型。其声明方式如下：</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> jvalue {
    jboolean    z;
    jbyte   b;
    jchar   c;
    jshort  s;
    jint    i;
    jlong   j;
    jfloat  f;
    jdouble d;
    jobject l;
} jvalue;</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li></ul></pre>



<h3 id="类型签名"><a name="t15"></a><a name="t15"></a>类型签名</h3>

<p>JNI使用Java虚拟机的类型签名表述。下表列出了这些类型签名：</p>

<div class="table-box"><table>
<thead>
<tr>
  <th>类型签名</th>
  <th align="left">Java 类型</th>
</tr>
</thead>
<tbody><tr>
  <td>Z</td>
  <td align="left">boolean</td>
</tr>
<tr>
  <td>B</td>
  <td align="left">byte</td>
</tr>
<tr>
  <td>C</td>
  <td align="left">char</td>
</tr>
<tr>
  <td>S</td>
  <td align="left">short</td>
</tr>
<tr>
  <td>I</td>
  <td align="left">int</td>
</tr>
<tr>
  <td>J</td>
  <td align="left">long</td>
</tr>
<tr>
  <td>F</td>
  <td align="left">float</td>
</tr>
<tr>
  <td>D</td>
  <td align="left">double</td>
</tr>
<tr>
  <td>L fully-qualified-class ;</td>
  <td align="left">全限定的类</td>
</tr>
<tr>
  <td>[ type</td>
  <td align="left">type[]</td>
</tr>
<tr>
  <td>( arg-types ) ret-type</td>
  <td align="left">方法类型</td>
</tr>
</tbody></table></div>


<p><br></p>

<p>例如，Java方法：</p>



<pre class="prettyprint" name="code"><code class="language-java hljs  has-numbering"><span class="hljs-keyword">long</span> f (<span class="hljs-keyword">int</span> n, String s, <span class="hljs-keyword">int</span>[] arr);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>具有以下类型签名：</p>



<pre class="prettyprint" name="code"><code class="hljs lisp has-numbering"><span class="hljs-list">(<span class="hljs-title">ILjava/lang/String</span><span class="hljs-comment">;[I)J</span></span></code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>



<h3 id="utf-8字符串"><a name="t16"></a><a name="t16"></a>UTF-8字符串</h3>

<p>JNI用UTF-8字符串来表示各种字符串类型。UTF-8字符串和Java虚拟机所使用的一样。UTF-8字符串的编码方式使得仅包含非空ASCII字符的字符序列能够按每字符一个字节表示，但是最多只能表示16位的字符。所有在\u0001到\u007F范围内的字符都用单字节表示，如下所示：</p>

<pre class="prettyprint"><code class="has-numbering">|0|0-6位|
</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>字节中的七位数据确定了所表示字符的值。空字符 (\u000)和\u0080到\u07FF范围内的字符用一对字节表示， 即x和y，如下所示：</p>

<pre class="prettyprint"><code class="has-numbering">x：|1|1|0|6-10位|             
y：|1|0|0-5位|
</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre>

<p>值为((x&amp;0x1f)&lt;&lt;6)+(y&amp;0x3f)的字符需用两个字节表示。\u0800到\uFFFF范围内的字符用三个字节表示，即x，y和z：</p>

<pre class="prettyprint"><code class="has-numbering">x：|1|1|1|0|12-15位|
y：|1|0|6-11位|
z：|1|0|0-5位|
</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre>

<p>值为((x&amp;0xf)&lt;&lt;12)+(y&amp;0x3f)&lt;&lt;6)+(z&amp;0x3f)的字符需用三个字节表示。</p>

<p>此格式与“标准” UTF-8格式之间有两个区别。第一，空字节(byte)0使用双字节格式进行编码，而不是单字节格式。这意味着Java虚拟机的UTF-8字符串不可能有嵌入的空值。第二，只使用单字节、双字节和三字节格式。Java虚拟机不能识别更长的UTF-8格式。</p>

<hr>



<h2 id="jni函数"><a name="t17"></a><a name="t17"></a>JNI函数</h2>

<p>本章为JNI函数提供参考信息。其中列出了全部JNI函数，同时也给出了JNI函数表的准确布局。注意：“必须”一词用于约束JNI编程人员。例如，当说明某个JNI函数必须接收非空对象时，就应确保不要向该JNI函数传递NULL。这时，JNI实现将无需在该JNI函数中执行NULL指针检查。本章的部分资料改编自Netscape的JRI文档。该参考资料按用法对函数进行组织。</p>



<h3 id="接口函数表"><a name="t18"></a><a name="t18"></a>接口函数表</h3>

<p>每个函数均可通过JNIEnv参数以固定偏移量进行访问。JNIEnv的类型是一个指针，指向存储全部JNI函数指针的结构。注意：前三项留作将来与COM兼容。此外，我们在函数表开头部分也留出来多个NULL项，从而可将将来与类有关的JNI操作添加到FindClass后面，而非函数表的末尾。注意，函数表可在所有JNI接口指针间共享。</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> JNINativeInterface ... = {
    NULL,
    NULL,
    NULL,
    NULL,
    GetVersion,

    DefineClass,
    FindClass,
    NULL,
    NULL,
    NULL,
    GetSuperclass,
    IsAssignableFrom,
    NULL,

    Throw,
    ThrowNew,
    ExceptionOccurred,
    ExceptionDescribe,
    ExceptionClear,
    FatalError,
    NULL,
    NULL,

    NewGlobalRef,
    DeleteGlobalRef,
    DeleteLocalRef,
    IsSameObject,
    NULL,
    NULL,
    AllocObject,

    NewObject,
    NewObjectV,
    NewObjectA,
    GetObjectClass,

    IsInstanceOf,

    GetMethodID,

    CallObjectMethod,
    CallObjectMethodV,
    CallObjectMethodA,
    CallBooleanMethod,
    CallBooleanMethodV,
    CallBooleanMethodA,
    CallByteMethod,
    CallByteMethodV,
    CallByteMethodA,
    CallCharMethod,
    CallCharMethodV,
    CallCharMethodA,
    CallShortMethod,
    CallShortMethodV,
    CallShortMethodA,
    CallIntMethod,
    CallIntMethodV,
    CallIntMethodA,
    CallLongMethod,
    CallLongMethodV,
    CallLongMethodA,
    CallFloatMethod,
    CallFloatMethodV,
    CallFloatMethodA,
    CallDoubleMethod,
    CallDoubleMethodV,
    CallDoubleMethodA,
    CallVoidMethod,
    CallVoidMethodV,
    CallVoidMethodA,

    CallNonvirtualObjectMethod,
    CallNonvirtualObjectMethodV,
    CallNonvirtualObjectMethodA,
    CallNonvirtualBooleanMethod,
    CallNonvirtualBooleanMethodV,
    CallNonvirtualBooleanMethodA,
    CallNonvirtualByteMethod,
    CallNonvirtualByteMethodV,
    CallNonvirtualByteMethodA,
    CallNonvirtualCharMethod,
    CallNonvirtualCharMethodV,
    CallNonvirtualCharMethodA,
    CallNonvirtualShortMethod,
    CallNonvirtualShortMethodV,
    CallNonvirtualShortMethodA,
    CallNonvirtualIntMethod,
    CallNonvirtualIntMethodV,
    CallNonvirtualIntMethodA,
    CallNonvirtualLongMethod,
    CallNonvirtualLongMethodV,
    CallNonvirtualLongMethodA,
    CallNonvirtualFloatMethod,
    CallNonvirtualFloatMethodV,
    CallNonvirtualFloatMethodA,
    CallNonvirtualDoubleMethod,
    CallNonvirtualDoubleMethodV,
    CallNonvirtualDoubleMethodA,
    CallNonvirtualVoidMethod,
    CallNonvirtualVoidMethodV,
    CallNonvirtualVoidMethodA,

    GetFieldID,

    GetObjectField,
    GetBooleanField,
    GetByteField,
    GetCharField,
    GetShortField,
    GetIntField,
    GetLongField,
    GetFloatField,
    GetDoubleField,
    SetObjectField,
    SetBooleanField,
    SetByteField,
    SetCharField,
    SetShortField,
    SetIntField,
    SetLongField,
    SetFloatField,
    SetDoubleField,

    GetStaticMethodID,

    CallStaticObjectMethod,
    CallStaticObjectMethodV,
    CallStaticObjectMethodA,
    CallStaticBooleanMethod,
    CallStaticBooleanMethodV,
    CallStaticBooleanMethodA,
    CallStaticByteMethod,
    CallStaticByteMethodV,
    CallStaticByteMethodA,
    CallStaticCharMethod,
    CallStaticCharMethodV,
    CallStaticCharMethodA,
    CallStaticShortMethod,
    CallStaticShortMethodV,
    CallStaticShortMethodA,
    CallStaticIntMethod,
    CallStaticIntMethodV,
    CallStaticIntMethodA,
    CallStaticLongMethod,
    CallStaticLongMethodV,
    CallStaticLongMethodA,
    CallStaticFloatMethod,
    CallStaticFloatMethodV,
    CallStaticFloatMethodA,
    CallStaticDoubleMethod,
    CallStaticDoubleMethodV,
    CallStaticDoubleMethodA,
    CallStaticVoidMethod,
    CallStaticVoidMethodV,
    CallStaticVoidMethodA,

    GetStaticFieldID,

    GetStaticObjectField,
    GetStaticBooleanField,
    GetStaticByteField,
    GetStaticCharField,
    GetStaticShortField,
    GetStaticIntField,
    GetStaticLongField,
    GetStaticFloatField,
    GetStaticDoubleField,

    SetStaticObjectField,
    SetStaticBooleanField,
    SetStaticByteField,
    SetStaticCharField,
    SetStaticShortField,
    SetStaticIntField,
    SetStaticLongField,
    SetStaticFloatField,
    SetStaticDoubleField,

    NewString,
    GetStringLength,
    GetStringChars,
    ReleaseStringChars,
    NewStringUTF,
    GetStringUTFLength,
    GetStringUTFChars,
    ReleaseStringUTFChars,

    GetArrayLength,

    NewObjectArray,
    GetObjectArrayElement,
    SetObjectArrayElement,

    NewBooleanArray,
    NewByteArray,
    NewCharArray,
    NewShortArray,
    NewIntArray,
    NewLongArray,
    NewFloatArray,
    NewDoubleArray,

    GetBooleanArrayElements,
    GetByteArrayElements,
    GetCharArrayElements,
    GetShortArrayElements,
    GetIntArrayElements,
    GetLongArrayElements,
    GetFloatArrayElements,
    GetDoubleArrayElements,

    ReleaseBooleanArrayElements,
    ReleaseByteArrayElements,
    ReleaseCharArrayElements,
    ReleaseShortArrayElements,
    ReleaseIntArrayElements,
    ReleaseLongArrayElements,
    ReleaseFloatArrayElements,
    ReleaseDoubleArrayElements,

    GetBooleanArrayRegion,
    GetByteArrayRegion,
    GetCharArrayRegion,
    GetShortArrayRegion,
    GetIntArrayRegion,
    GetLongArrayRegion,
    GetFloatArrayRegion,
    GetDoubleArrayRegion,
    SetBooleanArrayRegion,
    SetByteArrayRegion,
    SetCharArrayRegion,
    SetShortArrayRegion,
    SetIntArrayRegion,
    SetLongArrayRegion,
    SetFloatArrayRegion,
    SetDoubleArrayRegion,

    RegisterNatives,
    UnregisterNatives,

    MonitorEnter,
    MonitorExit,

    GetJavaVM,
};</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li><li style="color: rgb(153, 153, 153);">63</li><li style="color: rgb(153, 153, 153);">64</li><li style="color: rgb(153, 153, 153);">65</li><li style="color: rgb(153, 153, 153);">66</li><li style="color: rgb(153, 153, 153);">67</li><li style="color: rgb(153, 153, 153);">68</li><li style="color: rgb(153, 153, 153);">69</li><li style="color: rgb(153, 153, 153);">70</li><li style="color: rgb(153, 153, 153);">71</li><li style="color: rgb(153, 153, 153);">72</li><li style="color: rgb(153, 153, 153);">73</li><li style="color: rgb(153, 153, 153);">74</li><li style="color: rgb(153, 153, 153);">75</li><li style="color: rgb(153, 153, 153);">76</li><li style="color: rgb(153, 153, 153);">77</li><li style="color: rgb(153, 153, 153);">78</li><li style="color: rgb(153, 153, 153);">79</li><li style="color: rgb(153, 153, 153);">80</li><li style="color: rgb(153, 153, 153);">81</li><li style="color: rgb(153, 153, 153);">82</li><li style="color: rgb(153, 153, 153);">83</li><li style="color: rgb(153, 153, 153);">84</li><li style="color: rgb(153, 153, 153);">85</li><li style="color: rgb(153, 153, 153);">86</li><li style="color: rgb(153, 153, 153);">87</li><li style="color: rgb(153, 153, 153);">88</li><li style="color: rgb(153, 153, 153);">89</li><li style="color: rgb(153, 153, 153);">90</li><li style="color: rgb(153, 153, 153);">91</li><li style="color: rgb(153, 153, 153);">92</li><li style="color: rgb(153, 153, 153);">93</li><li style="color: rgb(153, 153, 153);">94</li><li style="color: rgb(153, 153, 153);">95</li><li style="color: rgb(153, 153, 153);">96</li><li style="color: rgb(153, 153, 153);">97</li><li style="color: rgb(153, 153, 153);">98</li><li style="color: rgb(153, 153, 153);">99</li><li style="color: rgb(153, 153, 153);">100</li><li style="color: rgb(153, 153, 153);">101</li><li style="color: rgb(153, 153, 153);">102</li><li style="color: rgb(153, 153, 153);">103</li><li style="color: rgb(153, 153, 153);">104</li><li style="color: rgb(153, 153, 153);">105</li><li style="color: rgb(153, 153, 153);">106</li><li style="color: rgb(153, 153, 153);">107</li><li style="color: rgb(153, 153, 153);">108</li><li style="color: rgb(153, 153, 153);">109</li><li style="color: rgb(153, 153, 153);">110</li><li style="color: rgb(153, 153, 153);">111</li><li style="color: rgb(153, 153, 153);">112</li><li style="color: rgb(153, 153, 153);">113</li><li style="color: rgb(153, 153, 153);">114</li><li style="color: rgb(153, 153, 153);">115</li><li style="color: rgb(153, 153, 153);">116</li><li style="color: rgb(153, 153, 153);">117</li><li style="color: rgb(153, 153, 153);">118</li><li style="color: rgb(153, 153, 153);">119</li><li style="color: rgb(153, 153, 153);">120</li><li style="color: rgb(153, 153, 153);">121</li><li style="color: rgb(153, 153, 153);">122</li><li style="color: rgb(153, 153, 153);">123</li><li style="color: rgb(153, 153, 153);">124</li><li style="color: rgb(153, 153, 153);">125</li><li style="color: rgb(153, 153, 153);">126</li><li style="color: rgb(153, 153, 153);">127</li><li style="color: rgb(153, 153, 153);">128</li><li style="color: rgb(153, 153, 153);">129</li><li style="color: rgb(153, 153, 153);">130</li><li style="color: rgb(153, 153, 153);">131</li><li style="color: rgb(153, 153, 153);">132</li><li style="color: rgb(153, 153, 153);">133</li><li style="color: rgb(153, 153, 153);">134</li><li style="color: rgb(153, 153, 153);">135</li><li style="color: rgb(153, 153, 153);">136</li><li style="color: rgb(153, 153, 153);">137</li><li style="color: rgb(153, 153, 153);">138</li><li style="color: rgb(153, 153, 153);">139</li><li style="color: rgb(153, 153, 153);">140</li><li style="color: rgb(153, 153, 153);">141</li><li style="color: rgb(153, 153, 153);">142</li><li style="color: rgb(153, 153, 153);">143</li><li style="color: rgb(153, 153, 153);">144</li><li style="color: rgb(153, 153, 153);">145</li><li style="color: rgb(153, 153, 153);">146</li><li style="color: rgb(153, 153, 153);">147</li><li style="color: rgb(153, 153, 153);">148</li><li style="color: rgb(153, 153, 153);">149</li><li style="color: rgb(153, 153, 153);">150</li><li style="color: rgb(153, 153, 153);">151</li><li style="color: rgb(153, 153, 153);">152</li><li style="color: rgb(153, 153, 153);">153</li><li style="color: rgb(153, 153, 153);">154</li><li style="color: rgb(153, 153, 153);">155</li><li style="color: rgb(153, 153, 153);">156</li><li style="color: rgb(153, 153, 153);">157</li><li style="color: rgb(153, 153, 153);">158</li><li style="color: rgb(153, 153, 153);">159</li><li style="color: rgb(153, 153, 153);">160</li><li style="color: rgb(153, 153, 153);">161</li><li style="color: rgb(153, 153, 153);">162</li><li style="color: rgb(153, 153, 153);">163</li><li style="color: rgb(153, 153, 153);">164</li><li style="color: rgb(153, 153, 153);">165</li><li style="color: rgb(153, 153, 153);">166</li><li style="color: rgb(153, 153, 153);">167</li><li style="color: rgb(153, 153, 153);">168</li><li style="color: rgb(153, 153, 153);">169</li><li style="color: rgb(153, 153, 153);">170</li><li style="color: rgb(153, 153, 153);">171</li><li style="color: rgb(153, 153, 153);">172</li><li style="color: rgb(153, 153, 153);">173</li><li style="color: rgb(153, 153, 153);">174</li><li style="color: rgb(153, 153, 153);">175</li><li style="color: rgb(153, 153, 153);">176</li><li style="color: rgb(153, 153, 153);">177</li><li style="color: rgb(153, 153, 153);">178</li><li style="color: rgb(153, 153, 153);">179</li><li style="color: rgb(153, 153, 153);">180</li><li style="color: rgb(153, 153, 153);">181</li><li style="color: rgb(153, 153, 153);">182</li><li style="color: rgb(153, 153, 153);">183</li><li style="color: rgb(153, 153, 153);">184</li><li style="color: rgb(153, 153, 153);">185</li><li style="color: rgb(153, 153, 153);">186</li><li style="color: rgb(153, 153, 153);">187</li><li style="color: rgb(153, 153, 153);">188</li><li style="color: rgb(153, 153, 153);">189</li><li style="color: rgb(153, 153, 153);">190</li><li style="color: rgb(153, 153, 153);">191</li><li style="color: rgb(153, 153, 153);">192</li><li style="color: rgb(153, 153, 153);">193</li><li style="color: rgb(153, 153, 153);">194</li><li style="color: rgb(153, 153, 153);">195</li><li style="color: rgb(153, 153, 153);">196</li><li style="color: rgb(153, 153, 153);">197</li><li style="color: rgb(153, 153, 153);">198</li><li style="color: rgb(153, 153, 153);">199</li><li style="color: rgb(153, 153, 153);">200</li><li style="color: rgb(153, 153, 153);">201</li><li style="color: rgb(153, 153, 153);">202</li><li style="color: rgb(153, 153, 153);">203</li><li style="color: rgb(153, 153, 153);">204</li><li style="color: rgb(153, 153, 153);">205</li><li style="color: rgb(153, 153, 153);">206</li><li style="color: rgb(153, 153, 153);">207</li><li style="color: rgb(153, 153, 153);">208</li><li style="color: rgb(153, 153, 153);">209</li><li style="color: rgb(153, 153, 153);">210</li><li style="color: rgb(153, 153, 153);">211</li><li style="color: rgb(153, 153, 153);">212</li><li style="color: rgb(153, 153, 153);">213</li><li style="color: rgb(153, 153, 153);">214</li><li style="color: rgb(153, 153, 153);">215</li><li style="color: rgb(153, 153, 153);">216</li><li style="color: rgb(153, 153, 153);">217</li><li style="color: rgb(153, 153, 153);">218</li><li style="color: rgb(153, 153, 153);">219</li><li style="color: rgb(153, 153, 153);">220</li><li style="color: rgb(153, 153, 153);">221</li><li style="color: rgb(153, 153, 153);">222</li><li style="color: rgb(153, 153, 153);">223</li><li style="color: rgb(153, 153, 153);">224</li><li style="color: rgb(153, 153, 153);">225</li><li style="color: rgb(153, 153, 153);">226</li><li style="color: rgb(153, 153, 153);">227</li><li style="color: rgb(153, 153, 153);">228</li><li style="color: rgb(153, 153, 153);">229</li><li style="color: rgb(153, 153, 153);">230</li><li style="color: rgb(153, 153, 153);">231</li><li style="color: rgb(153, 153, 153);">232</li><li style="color: rgb(153, 153, 153);">233</li><li style="color: rgb(153, 153, 153);">234</li><li style="color: rgb(153, 153, 153);">235</li><li style="color: rgb(153, 153, 153);">236</li><li style="color: rgb(153, 153, 153);">237</li><li style="color: rgb(153, 153, 153);">238</li><li style="color: rgb(153, 153, 153);">239</li><li style="color: rgb(153, 153, 153);">240</li><li style="color: rgb(153, 153, 153);">241</li><li style="color: rgb(153, 153, 153);">242</li><li style="color: rgb(153, 153, 153);">243</li><li style="color: rgb(153, 153, 153);">244</li><li style="color: rgb(153, 153, 153);">245</li><li style="color: rgb(153, 153, 153);">246</li><li style="color: rgb(153, 153, 153);">247</li></ul></pre>



<h3 id="版本信息"><a name="t19"></a><a name="t19"></a>版本信息</h3>



<h4 id="getversion-返回本地方法接口的版本">GetVersion 返回本地方法接口的版本。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint GetVersion(JNIEnv *env);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数 <br>
    env：JNI接口指针。</p>

<p>返回值： <br>
    高16位返回主版本号，低16位返回次版本号。 <br>
    在JDK1.1 中，GetVersion()返回0x00010001。</p>



<h3 id="类操作"><a name="t20"></a><a name="t20"></a>类操作</h3>



<h4 id="defineclass-从原始类数据的缓冲区中加载类">DefineClass 从原始类数据的缓冲区中加载类。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jclass DefineClass(JNIEnv *env, jobject loader, <span class="hljs-keyword">const</span> jbyte *buf, jsize bufLen);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI 接口指针。 <br>
    loader：分派给所定义的类的类加载器。 <br>
    buf：包含.class文件数据的缓冲区。 <br>
    bufLen：缓冲区长度。</p>

<p>返回值： <br>
    返回Java类对象。如果出错则返回NULL。</p>

<p>抛出： <br>
    ClassFormatError：如果类数据指定的类无效。 <br>
    ClassCircularityError：如果类或接口是自身的超类或超接口。 <br>
    OutOfMemoryError：如果系统内存不足。</p>



<h4 id="findclass-该函数用于加载本地定义的类它将搜索由classpath环境变量为具有指定名称的类所指定的目录和zip文件">FindClass 该函数用于加载本地定义的类。它将搜索由CLASSPATH环境变量为具有指定名称的类所指定的目录和zip文件。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jclass FindClass(JNIEnv *env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    name：类全名（即包名后跟类名，之间由“/”分隔）。如果该名称以“[”（数组签名字符）打头，则返回一个数组类。</p>

<p>返回值： <br>
    返回类对象全名。如果找不到该类，则返回NULL。</p>

<p>抛出： <br>
    ClassFormatError：如果类数据指定的类无效。 <br>
    ClassCircularityError：如果类或接口是自身的超类或超接口。 <br>
    NoClassDefFoundError：如果找不到所请求的类或接口的定义。 <br>
    OutOfMemoryError：如果系统内存不足。</p>



<h4 id="getsuperclass-如果clazz代表类而非类object则该函数返回由clazz所指定的类的超类如果clazz指定类object或代表某个接口则该函数返回null">GetSuperclass 如果clazz代表类而非类object，则该函数返回由clazz所指定的类的超类。如果clazz指定类object或代表某个接口，则该函数返回NULL。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jclass GetSuperclass(JNIEnv *env, jclass clazz);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类对象。</p>

<p>返回值： <br>
由clazz所代表的类的超类或NULL。</p>



<h4 id="isassignablefrom-确定clazz1的对象是否可安全地强制转换为clazz2">IsAssignableFrom 确定clazz1的对象是否可安全地强制转换为clazz2。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jboolean IsAssignableFrom(JNIEnv *env, jclass clazz1, jclass clazz2);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz1：第一个类参数。 <br>
    clazz2：第二个类参数。</p>

<p>返回值： <br>
    下列某个情况为真时返回JNI_TRUE： <br>
        第一及第二个类参数引用同一个Java类。 <br>
        第一个类是第二个类的子类。 <br>
        第二个类是第一个类的某个接口。</p>



<h3 id="异常"><a name="t21"></a><a name="t21"></a>异常</h3>



<h4 id="throw-抛出javalangthrowable对象">Throw 抛出java.lang.Throwable对象。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint Throw(JNIEnv *env, jthrowable obj);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    obj：java.lang.Throwable对象。</p>

<p>返回值： <br>
    成功时返回0，失败时返回负数。</p>

<p>抛出： <br>
    java.lang.Throwable对象obj。</p>



<h4 id="thrownew利用指定类的消息由message指定构造异常对象并抛出该异常">ThrowNew利用指定类的消息（由message指定）构造异常对象并抛出该异常。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint ThrowNew(JNIEnv *env, jclass clazz, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *message);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：java.lang.Throwable的子类。 <br>
    message：用于构造java.lang.Throwable对象的消息。</p>

<p>返回值： <br>
    成功时返回0，失败时返回负数。</p>

<p>抛出： <br>
    新构造的java.lang.Throwable对象。</p>



<h4 id="exceptionoccurred-确定是否某个异常正被抛出在平台相关代码调用exceptionclear或java代码处理该异常前异常将始终保持抛出状态">ExceptionOccurred 确定是否某个异常正被抛出。在平台相关代码调用ExceptionClear()或Java代码处理该异常前，异常将始终保持抛出状态。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jthrowable ExceptionOccurred(JNIEnv *env);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。</p>

<p>返回值： <br>
    返回正被抛出的异常对象，如果当前无异常被抛出，则返回NULL。</p>



<h4 id="exceptiondescribe-将异常及堆栈的回溯输出到系统错误报告信道例如-stderr该例程可便利调试操作">ExceptionDescribe 将异常及堆栈的回溯输出到系统错误报告信道（例如 stderr）。该例程可便利调试操作。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> ExceptionDescribe(JNIEnv *env);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。</p>



<h4 id="exceptionclear-清除当前抛出的任何异常如果当前无异常则此例程不产生任何效果">ExceptionClear 清除当前抛出的任何异常。如果当前无异常，则此例程不产生任何效果。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> ExceptionClear(JNIEnv *env);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。</p>



<h4 id="fatalerror-抛出致命错误并且不希望虚拟机进行修复该函数无返回值">FatalError 抛出致命错误并且不希望虚拟机进行修复。该函数无返回值。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> FatalError(JNIEnv *env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *msg);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    msg：错误消息。</p>



<h3 id="全局及局部引用"><a name="t22"></a><a name="t22"></a>全局及局部引用</h3>



<h4 id="newglobalref-创建obj参数所引用对象的新全局引用obj参数既可以是全局引用也可以是局部引用全局引用通过调用deleteglobalref来显式撤消">NewGlobalRef 创建obj参数所引用对象的新全局引用。obj参数既可以是全局引用，也可以是局部引用。全局引用通过调用DeleteGlobalRef()来显式撤消。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jobject NewGlobalRef(JNIEnv *env, jobject obj);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    obj：全局或局部引用。</p>

<p>返回值： <br>
    返回全局引用。如果系统内存不足则返回NULL。</p>



<h4 id="deleteglobalref-删除globalref所指向的全局引用">DeleteGlobalRef 删除globalRef所指向的全局引用。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> DeleteGlobalRef(JNIEnv *env, jobject globalRef);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    globalRef：全局引用。</p>



<h4 id="deletelocalref-删除localref所指向的局部引用">DeleteLocalRef 删除localRef所指向的局部引用。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> DeleteLocalRef(JNIEnv *env, jobject localRef);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    localRef：局部引用。</p>



<h3 id="对象操作"><a name="t23"></a><a name="t23"></a>对象操作</h3>



<h4 id="allocobject-分配新java对象而不调用该对象的任何构造函数返回该对象的引用clazz参数务必不要引用数组类">AllocObject 分配新Java对象而不调用该对象的任何构造函数。返回该对象的引用。clazz参数务必不要引用数组类。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jobject AllocObject(JNIEnv *env, jclass clazz);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类对象。</p>

<p>返回值： <br>
    返回Java对象。如果无法构造该对象，则返回NULL。</p>

<p>抛出： <br>
    InstantiationException：如果该类为一个接口或抽象类。 <br>
    OutOfMemoryError：如果系统内存不足。</p>



<h4 id="newobject-newobjecta-newobjectv-构造新java对象">NewObject NewObjectA NewObjectV 构造新Java对象。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jobject NewObject(JNIEnv *env, jclass clazz, jmethodID methodID, ...);
jobject NewObjectA(JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);
jobject NewObjectV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre>

<p>方法ID指示应调用的构造函数方法。该ID必须通过调用GetMethodID()获得，且调用时的方法名必须为init，而返回类型必须为void(V)。clazz参数务必不要引用数组类。</p>



<h5 id="newobject">NewObject</h5>

<p>编程人员应将传递给构造函数的所有参数紧跟着放在methodID参数的后面。NewObject()收到这些参数后，将把它们传给编程人员所要调用的Java方法。</p>



<h5 id="newobjecta">NewObjectA</h5>

<p>编程人员应将传递给构造函数的所有参数放在jvalues类型的数组args中，该数组紧跟着放在methodID参数的后面。NewObject()收到数组中的这些参数后，将把它们传给编程人员所要调用的Java方法。</p>



<h5 id="newobjectv">NewObjectV</h5>

<p>编程人员应将传递给构造函数的所有参数放在va_list类型的参数args中，该参数紧跟着放在methodID参数的后面。NewObject()收到这些参数后，将把它们传给编程人员所要调用的Java方法。</p>

<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类对象。 <br>
    methodID：构造函数的方法ID。</p>

<p>NewObject 的其它参数： <br>
    传给构造函数的参数。</p>

<p>NewObjectA的其它参数： <br>
    args：传给构造函数的参数数组。</p>

<p>NewObjectV的其它参数： <br>
    args：传给构造函数的参数va_list。</p>

<p>返回值： <br>
返回Java对象，如果无法构造该对象，则返回NULL。</p>

<p>抛出： <br>
    InstantiationException：如果该类为接口或抽象类。 <br>
    OutOfMemoryError：如果系统内存不足。 <br>
    构造函数抛出的任何异常。</p>



<h4 id="getobjectclass-返回对象的类">GetObjectClass 返回对象的类。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jclass GetObjectClass(JNIEnv *env, jobject obj);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    obj：Java对象（不能为NULL）。</p>

<p>返回值： <br>
    返回Java类对象。</p>



<h4 id="isinstanceof-测试对象是否为某个类的实例">IsInstanceOf 测试对象是否为某个类的实例。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jboolean IsInstanceOf(JNIEnv *env, jobject obj, jclass clazz);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    obj：Java对象。 <br>
    clazz：Java类对象。</p>

<p>返回值： <br>
    如果可将obj强制转换为clazz，则返回JNI_TRUE。否则返回JNI_FALSE。NULL对象可强制转换为任何类。</p>



<h4 id="issameobject-测试两个引用是否引用同一java对象">IsSameObject 测试两个引用是否引用同一Java对象。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jboolean IsSameObject(JNIEnv *env, jobject ref1, jobject ref2);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    ref1：Java对象。 <br>
    ref2：Java对象。</p>

<p>返回值： <br>
    如果ref1和ref2引用同一Java对象或均为NULL，则返回JNI_TRUE。否则返回JNI_FALSE。</p>



<h3 id="访问对象的域"><a name="t24"></a><a name="t24"></a>访问对象的域</h3>



<h4 id="getfieldid">GetFieldID</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jfieldID GetFieldID(JNIEnv *env, jclass clazz, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sig);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>返回类的实例（非静态）域的域ID。该域由其名称及签名指定。访问器函数的Get[type]Field及Set[type]Field系列使用域ID检索 <br>
对象域。GetFieldID()将未初始化的类初始化。GetFieldID()不能用于获取数组的长度域。应使用GetArrayLength()。</p>

<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类对象。 <br>
    name: 0终结的UTF-8字符串中的域名。 <br>
    sig：0终结的UTF-8字符串中的域签名。</p>

<p>返回值： <br>
    域ID。如果操作失败，则返回NULL。</p>

<p>抛出： <br>
    NoSuchFieldError：如果找不到指定的域。 <br>
    ExceptionInInitializerError：如果由于异常而导致类初始化程序失败。 <br>
    OutOfMemoryError：如果系统内存不足。</p>



<h4 id="gettypefield例程">Get[type]Field例程</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">NativeType Get[type]Field(JNIEnv *env, jobject obj, jfieldID fieldID);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>该访问器例程系列返回对象的实例（非静态）域的值。要访问的域由通过调用GetFieldID()而得到的域ID指定。下表说明了Get[type]Field例程名及结果类型。应将Get[type]Field中的type替换为域的Java类型（或使用表中的某个实际例程名），然后将NativeType替换为该例程对应的本地类型。</p>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>Get[type]Field例程名</em></th>
  <th align="left"><em>本地类型</em></th>
</tr>
</thead>
<tbody><tr>
  <td>GetObjectField()</td>
  <td align="left">jobject</td>
</tr>
<tr>
  <td>GetBooleanField()</td>
  <td align="left">jboolean</td>
</tr>
<tr>
  <td>GetByteField()</td>
  <td align="left">jbyte</td>
</tr>
<tr>
  <td>GetCharField()</td>
  <td align="left">jchar</td>
</tr>
<tr>
  <td>GetShortField()</td>
  <td align="left">jshort</td>
</tr>
<tr>
  <td>GetIntField()</td>
  <td align="left">jint</td>
</tr>
<tr>
  <td>GetLongField()</td>
  <td align="left">jlong</td>
</tr>
<tr>
  <td>GetFloatField()</td>
  <td align="left">jfloat</td>
</tr>
<tr>
  <td>GetDoubleField()</td>
  <td align="left">jdouble</td>
</tr>
</tbody></table></div>


<p><br>
参数： <br>
    env：JNI接口指针。 <br>
    obj：Java对象（不能为 NULL）。 <br>
    fieldID：有效的域ID。</p>

<p>返回值： <br>
    域的内容。</p>



<h4 id="settypefield例程">Set[type]Field例程</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> Set[type]Field(JNIEnv *env, jobject obj, jfieldID fieldID, NativeType value);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>该访问器例程系列设置对象的实例（非静态）域的值。要访问的域由通过调用SetFieldID()而得到的域ID指定。下表说明了Set[type]Field例程名及结果类型。应将Set[type]Field中的type替换为域的Java类型（或使用表中的某个实际例程名），然后将NativeType替换为该例程对应的本地类型。</p>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>Set[type]Field例程名</em></th>
  <th align="left"><em>本地类型</em></th>
</tr>
</thead>
<tbody><tr>
  <td>SetObjectField()</td>
  <td align="left">jobject</td>
</tr>
<tr>
  <td>SetBooleanField()</td>
  <td align="left">jboolean</td>
</tr>
<tr>
  <td>SetByteField()</td>
  <td align="left">jbyte</td>
</tr>
<tr>
  <td>SetCharField()</td>
  <td align="left">jchar</td>
</tr>
<tr>
  <td>SetShortField()</td>
  <td align="left">jshort</td>
</tr>
<tr>
  <td>SetIntField()</td>
  <td align="left">jint</td>
</tr>
<tr>
  <td>SetLongField()</td>
  <td align="left">jlong</td>
</tr>
<tr>
  <td>SetFloatField()</td>
  <td align="left">jfloat</td>
</tr>
<tr>
  <td>SetDoubleField()</td>
  <td align="left">jdouble</td>
</tr>
</tbody></table></div>


<p>参数： <br>
    env：JNI接口指针。 <br>
    obj：Java对象（不能为NULL）。 <br>
    fieldID：有效的域ID。 <br>
    value：域的新值。</p>



<h3 id="调用实例方法"><a name="t25"></a><a name="t25"></a>调用实例方法</h3>



<h4 id="getmethodid">GetMethodID</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jmethodID GetMethodID(JNIEnv *env, jclass clazz, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sig);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>返回类或接口实例（非静态）方法的方法ID。方法可在某个clazz的超类中定义，也可从clazz继承。该方法由其名称和签名决定。GetMethodID()可使未初始化的类初始化。要获得构造函数的方法ID，应将[init]作为方法名，同时将void (V)作为返回类型。</p>

<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类对象。 <br>
    name：0终结的UTF-8字符串中的方法名。 <br>
    sig：0终结的UTF-8字符串中的方法签名。</p>

<p>返回值： <br>
    方法ID，如果找不到指定的方法，则为NULL。</p>

<p>抛出： <br>
    NoSuchMethodError：如果找不到指定方法。 <br>
    ExceptionInInitializerError：如果由于异常而导致类初始化程序失败。 <br>
    OutOfMemoryError：如果系统内存不足。</p>



<h4 id="calltypemethodcalltypemethodacalltypemethodv例程">Call[type]Method，Call[type]MethodA，Call[type]MethodV例程</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">NativeType Call[type]Method(JNIEnv *env, jobject obj, jmethodID methodID, ...);
NativeType Call[type]MethodA(JNIEnv *env, jobject obj, jmethodID methodID, jvalue *args);
NativeType Call[type]MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre>

<p>这三个操作的方法用于从本地方法调用Java实例方法。它们的差别仅在于向其所调用的方法传递参数时所用的机制。这三个操作将根据所指定的方法ID调用Java对象的实例（非静态）方法。参数methodID必须通过调用GetMethodID()来获得。当这些函数用于调用私有方法和构造函数时，方法ID必须从obj的真实类派生而来，而不应从其某个超类派生。</p>



<h5 id="calltypemethod例程">Call[type]Method例程</h5>

<p>编程人员应将要传给方法的所有参数紧跟着放在methodID参数之后。Call[type]Method例程接受这些参数并将其传给编程人员所要调用的Java方法。</p>



<h5 id="calltypemethoda例程">Call[type]MethodA例程</h5>

<p>编程人员应将要传给方法的所有参数放在紧跟在methodID参数之后的jvalues类型数组args中。Call[type]MethodA routine接受这些数组中的参数并将其传给编程人员所要调用的Java方法。</p>



<h5 id="calltypemethodv-例程">Call[type]MethodV 例程</h5>

<p>编程人员将方法的所有参数放在紧跟着在methodID参数之后的va_list类型参数变量中。Call[type]MethodV routine接受这些参数并将其传给编程人员所要调用的Java方法。</p>

<p>下表根据结果类型说明了各个方法调用例程。用户应将Call[type]Method中的type替换为所调用方法的Java类型（或使用表中的实际方法调用例程名），同时将NativeType替换为该例程相应的本地类型。</p>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>Call[type]Method例程名</em></th>
  <th align="left"><em>本地类型</em></th>
</tr>
</thead>
<tbody><tr>
  <td>CallVoidMethod() CallVoidMethodA() CallVoidMethodV()</td>
  <td align="left">void</td>
</tr>
<tr>
  <td>CallObjectMethod() CallObjectMethodA() CallObjectMethodV()</td>
  <td align="left">jobject</td>
</tr>
<tr>
  <td>CallBooleanMethod() CallBooleanMethodA() CallBooleanMethodV()</td>
  <td align="left">jboolean</td>
</tr>
<tr>
  <td>CallByteMethod() CallByteMethodA() CallByteMethodV()</td>
  <td align="left">jbyte</td>
</tr>
<tr>
  <td>CallCharMethod() CallCharMethodA() CallCharMethodV()</td>
  <td align="left">jchar</td>
</tr>
<tr>
  <td>CallShortMethod() CallShortMethodA() CallShortMethodV()</td>
  <td align="left">jshort</td>
</tr>
<tr>
  <td>CallIntMethod() CallIntMethodA() CallIntMethodV()</td>
  <td align="left">jint</td>
</tr>
<tr>
  <td>CallLongMethod() CallLongMethodA() CallLongMethodV()</td>
  <td align="left">jlong</td>
</tr>
<tr>
  <td>CallFloatMethod() CallFloatMethodA() CallFloatMethodV()</td>
  <td align="left">jfloat</td>
</tr>
<tr>
  <td>CallDoubleMethod() CallDoubleMethodA() CallDoubleMethodV()</td>
  <td align="left">jdouble</td>
</tr>
</tbody></table></div>


<p><br>
参数： <br>
    env：JNI接口指针。 <br>
    obj：Java对象。 <br>
    methodID：方法ID。</p>

<p>Call[type]Method例程的其它参数： <br>
    要传给Java方法的参数。</p>

<p>Call[type]MethodA例程的其它参数： <br>
    args：参数数组。</p>

<p>Call[type]MethodV例程的其它参数： <br>
    args：参数的va_list。</p>

<p>返回值： <br>
    返回调用Java方法的结果。</p>

<p>抛出： <br>
    执行Java方法时抛出的异常。</p>



<h4 id="callnonvirtualtypemethodcallnonvirtualtypemethodacallnonvirtualtypemethodv例程">CallNonvirtual[type]Method，CallNonvirtual[type]MethodA，CallNonvirtual[type]MethodV例程</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">NativeType CallNonvirtual[type]Method(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);
NativeType CallNonvirtual[type]MethodA(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, jvalue *args);
NativeType CallNonvirtual[type]MethodV(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre>

<p>这些操作根据指定的类和方法ID调用某Java对象的实例（非静态）方法。参数methodID必须通过调用clazz类的GetMethodID()获得。CallNonvirtual[type]Method和Call[type]Method例程系列并不相同。Call[type]Method例程根据对象的类调用方法，而CallNonvirtual[type]Method例程则根据获得方法ID的（由clazz参数指定）类调用方法。方法ID必须从对象的真实类或其某个超类获得。</p>



<h5 id="callnonvirtualtypemethod例程">CallNonvirtual[type]Method例程</h5>

<p>编程人员应将要传给方法的所有参数紧跟着放在methodID参数之后。CallNonvirtual[type]Method routine接受这些参数并将其传给编程人员所要调用的Java方法。</p>



<h5 id="callnonvirtualtypemethoda例程">CallNonvirtual[type]MethodA例程</h5>

<p>编程人员应将要传给方法的所有参数放在紧跟在methodID参数之后的jvalues类型数组args中。 <br>
CallNonvirtual[type]MethodA routine接受这些数组中的参数并将其传给编程人员所要调用的Java方法。</p>



<h5 id="callnonvirtualtypemethodv例程">CallNonvirtual[type]MethodV例程</h5>

<p>编程人员应将要传给方法的所有参数放在紧跟在methodID参数之后的va_list类型参数args中。CallNonvirtualMethodV routine接受这些参数并将其传给编程人员所要调用的Java方法。</p>

<p>下表根据结果类型说明了各个方法调用例程。用户应将CallNonvirtual[type]Method中的type替换为所调用方法的Java类型（或使用表中的实际方法调用例程名），同时将NativeType替换为该例程相应的本地类型。</p>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>CallNonvirtual[type]Method例程名</em></th>
  <th align="left"><em>本地类型</em></th>
</tr>
</thead>
<tbody><tr>
  <td>CallNonvirtualVoidMethod() CallNonvirtualVoidMethodA() CallNonvirtualVoidMethodV()</td>
  <td align="left">void</td>
</tr>
<tr>
  <td>CallNonvirtualObjectMethod() CallNonvirtualObjectMethodA() CallNonvirtualObjectMethodV()</td>
  <td align="left">jobject</td>
</tr>
<tr>
  <td>CallNonvirtualBooleanMethod() CallNonvirtualBooleanMethodA() CallNonvirtualBooleanMethodV()</td>
  <td align="left">jboolean</td>
</tr>
<tr>
  <td>CallNonvirtualByteMethod() CallNonvirtualByteMethodA() CallNonvirtualByteMethodV()</td>
  <td align="left">jbyte</td>
</tr>
<tr>
  <td>CallNonvirtualCharMethod() CallNonvirtualCharMethodA() CallNonvirtualCharMethodV()</td>
  <td align="left">jchar</td>
</tr>
<tr>
  <td>CallNonvirtualShortMethod() CallNonvirtualShortMethodA() CallNonvirtualShortMethodV()</td>
  <td align="left"></td>
</tr>
<tr>
  <td>CallNonvirtualIntMethod() CallNonvirtualIntMethodA() CallNonvirtualIntMethodV()</td>
  <td align="left">jint</td>
</tr>
<tr>
  <td>CallNonvirtualLongMethod() CallNonvirtualLongMethodA() CallNonvirtualLongMethodV()</td>
  <td align="left">jlong</td>
</tr>
<tr>
  <td>CallNonvirtualFloatMethod() CallNonvirtualFloatMethodA() CallNonvirtualFloatMethodV()</td>
  <td align="left">jfloat</td>
</tr>
<tr>
  <td>CallNonvirtualDoubleMethod() CallNonvirtualDoubleMethodA() CallNonvirtualDoubleMethodV()</td>
  <td align="left">jdouble</td>
</tr>
</tbody></table></div>


<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类。 <br>
    obj: Java对象。 <br>
    methodID：方法ID。</p>

<p>CallNonvirtual[type]Method例程的其它参数： <br>
    要传给Java方法的参数。</p>

<p>CallNonvirtual[type]MethodA例程的其它参数： <br>
    args：参数数组。</p>

<p>CallNonvirtual[type]MethodV例程的其它参数： <br>
    args：参数的va_list。</p>

<p>返回值： <br>
    调用Java方法的结果。</p>

<p>抛出： <br>
    执行Java方法时所抛出的异常。</p>



<h3 id="访问静态域"><a name="t26"></a><a name="t26"></a>访问静态域</h3>



<h4 id="getstaticfieldid">GetStaticFieldID</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jfieldID GetStaticFieldID(JNIEnv *env, jclass clazz, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sig);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>返回类的静态域的域ID。域由其名称和签名指定。GetStatic[type]Field和SetStatic[type]Field访问器函数系列使用域ID检索静态域。GetStaticFieldID()将未初始化的类初始化。</p>

<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类对象。 <br>
    name: 0终结的UTF-8字符串中的静态域名。 <br>
    sig：0终结的UTF-8字符串中的域签名。</p>

<p>返回值： <br>
    域ID。如果找不到指定的静态域，则为NULL。</p>

<p>抛出： <br>
    NoSuchFieldError：如果找不到指定的静态域。 <br>
    ExceptionInInitializerError：如果由于异常而导致类初始化程序失败。 <br>
    OutOfMemoryError：如果系统内存不足。</p>



<h4 id="getstatictypefield例程">GetStatic[type]Field例程</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">NativeType GetStatic[type]Field(JNIEnv *env, jclass clazz, jfieldID fieldID);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>该访问器例程系列返回对象的静态域的值。要访问的域由通过调用GetStaticFieldID()而得到的域ID指定。下表说明了GetStatic[type]Field例程名及结果类型。应将GetStatic[type]Field中的type替换为域的Java类型（或使用表中的某个实际例程名），然后将NativeType替换为该例程对应的本地类型。</p>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>GetStatic[type]Field例程名</em></th>
  <th align="left"></th>
  <th><em>本地类型</em></th>
</tr>
</thead>
<tbody><tr>
  <td>GetStaticObjectField()</td>
  <td align="left">jobject</td>
  <td></td>
</tr>
<tr>
  <td>GetStaticBooleanField()</td>
  <td align="left">jboolean</td>
  <td></td>
</tr>
<tr>
  <td>GetStaticByteField()</td>
  <td align="left">jbyte</td>
  <td></td>
</tr>
<tr>
  <td>GetStaticCharField()</td>
  <td align="left">jchar</td>
  <td></td>
</tr>
<tr>
  <td>GetStaticShortField()</td>
  <td align="left">jshort</td>
  <td></td>
</tr>
<tr>
  <td>GetStaticIntField()</td>
  <td align="left">jint</td>
  <td></td>
</tr>
<tr>
  <td>GetStaticLongField()</td>
  <td align="left">jlong</td>
  <td></td>
</tr>
<tr>
  <td>GetStaticFloatField()</td>
  <td align="left">jfloat</td>
  <td></td>
</tr>
<tr>
  <td>GetStaticDoubleField()</td>
  <td align="left">jdouble</td>
  <td></td>
</tr>
</tbody></table></div>


<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类对象。 <br>
    fieldID：静态域ID。 <br>
返回值： <br>
    静态域的内容。</p>



<h4 id="setstatictypefield例程">SetStatic[type]Field例程</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> SetStatic[type]Field(JNIEnv *env, jclass clazz, jfieldID fieldID, NativeType value);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>该访问器例程系列设置对象的静态域的值。要访问的域由通过调用GetStaticFieldID()而得到的域ID指定。下表说明了SetStatic[type]Field例程名及结果类型。应将SetStatic[type]Field中的type替换为域的Java类型（或使用表中的某个实际例程名），然后将NativeType替换为该例程对应的本地类型。</p>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>SetStatic[type]Field例程名</em></th>
  <th align="left"><em>本地类型</em></th>
</tr>
</thead>
<tbody><tr>
  <td>SetStaticObjectField()</td>
  <td align="left">jobject</td>
</tr>
<tr>
  <td>SetStaticBooleanField()</td>
  <td align="left">jboolean</td>
</tr>
<tr>
  <td>SetStaticByteField()</td>
  <td align="left">jbyte</td>
</tr>
<tr>
  <td>SetStaticCharField()</td>
  <td align="left">jchar</td>
</tr>
<tr>
  <td>SetStaticShortField()</td>
  <td align="left">jshort</td>
</tr>
<tr>
  <td>SetStaticIntField()</td>
  <td align="left">jint</td>
</tr>
<tr>
  <td>SetStaticLongField()</td>
  <td align="left">jlong</td>
</tr>
<tr>
  <td>SetStaticFloatField()</td>
  <td align="left">jfloat</td>
</tr>
<tr>
  <td>SetStaticDoubleField()</td>
  <td align="left">jdouble</td>
</tr>
</tbody></table></div>


<p><br>
参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类对象。 <br>
    fieldID：静态域ID。 <br>
    value：域的新值。</p>



<h3 id="调用静态方法"><a name="t27"></a><a name="t27"></a>调用静态方法</h3>



<h4 id="getstaticmethodid-返回类的静态方法的方法id方法由其名称和签名指定getstaticmethodid将未初始化的类初始化">GetStaticMethodID 返回类的静态方法的方法ID。方法由其名称和签名指定。GetStaticMethodID()将未初始化的类初始化。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jmethodID GetStaticMethodID(JNIEnv *env, jclass clazz, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *sig);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类对象。 <br>
    name：0终结UTF-8字符串中的静态方法名。 <br>
    sig：0终结UTF-8字符串中的方法签名。</p>

<p>返回值： <br>
    方法ID，如果操作失败，则为NULL。</p>

<p>抛出： <br>
    NoSuchMethodError：如果找不到指定的静态方法。 <br>
    ExceptionInInitializerError：如果由于异常而导致类初始化程序失败。 <br>
    OutOfMemoryError：如果系统内存不足。</p>



<h4 id="callstatictypemethodcallstatictypemethodacallstatictypemethodv-例程">CallStatic[type]Method，CallStatic[type]MethodA，CallStatic[type]MethodV 例程</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">NativeType CallStatic[type]Method(JNIEnv *env, jclass clazz, jmethodID methodID, ...);
NativeType CallStatic[type]MethodA(JNIEnv *env, jclass clazz, jmethodID methodID, jvalue *args);
NativeType CallStatic[type]MethodV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre>

<p>这些操作将根据指定的方法ID调用Java对象的静态方法。methodID参数必须通过调用GetStaticMethodID()得到。方法ID必须从clazz派生，而不能从其超类派生。</p>



<h5 id="callstatictypemethod例程">CallStatic[type]Method例程</h5>

<p>编程人员应将要传给方法的所有参数紧跟着放在methodID参数之后。CallStatic[type]Method routine接受这些参数并将其传给编程人员所要调用的Java方法。</p>



<h5 id="callstatictypemethoda例程">CallStatic[type]MethodA例程</h5>

<p>编程人员应将要传给方法的所有参数放在紧跟在methodID参数之后的jvalues类型数组args中。CallStaticMethodA routine接受这些数组中的参数并将其传给编程人员所要调用的Java方法。</p>



<h5 id="callstatictypemethodv例程">CallStatic[type]MethodV例程</h5>

<p>编程人员应将要传给方法的所有参数放在紧跟在methodID参数之后的va_list类型参数args中。CallStaticMethodV routine接受这些参数并将其传给编程人员所要调用的Java方法。</p>

<p>下表根据结果类型说明了各个方法调用例程。用户应将CallStatic[type]Method中的type替换为所调用方法的Java类型（或使用表中的实际方法调用例程名），同时将NativeType替换为该例程相应的本地类型。</p>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>CallStatic[type]Method例程名</em></th>
  <th align="left"><em>本地类型</em></th>
</tr>
</thead>
<tbody><tr>
  <td>CallStaticVoidMethod() CallStaticVoidMethodA() CallStaticVoidMethodV()</td>
  <td align="left">void</td>
</tr>
<tr>
  <td>CallStaticObjectMethod() CallStaticObjectMethodA() CallStaticObjectMethodV()</td>
  <td align="left">jobject</td>
</tr>
<tr>
  <td>CallStaticBooleanMethod() CallStaticBooleanMethodA() CallStaticBooleanMethodV()</td>
  <td align="left">jboolean</td>
</tr>
<tr>
  <td>CallStaticByteMethod() CallStaticByteMethodA() CallStaticByteMethodV()</td>
  <td align="left">jbyte</td>
</tr>
<tr>
  <td>CallStaticCharMethod() CallStaticCharMethodA() CallStaticCharMethodV()</td>
  <td align="left">jchar</td>
</tr>
<tr>
  <td>CallStaticShortMethod() CallStaticShortMethodA() CallStaticShortMethodV()</td>
  <td align="left">jshort</td>
</tr>
<tr>
  <td>CallStaticIntMethod() CallStaticIntMethodA() CallStaticIntMethodV()</td>
  <td align="left">jint</td>
</tr>
<tr>
  <td>CallStaticLongMethod() CallStaticLongMethodA() CallStaticLongMethodV()</td>
  <td align="left">jlong</td>
</tr>
<tr>
  <td>CallStaticFloatMethod() CallStaticFloatMethodA() CallStaticFloatMethodV()</td>
  <td align="left">jfloat</td>
</tr>
<tr>
  <td>CallStaticDoubleMethod() CallStaticDoubleMethodA() CallStaticDoubleMethodV()</td>
  <td align="left">jdouble</td>
</tr>
</tbody></table></div>


<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类对象。 <br>
    methodID：静态方法ID。</p>

<p>CallStatic[type]Method例程的其它参数： <br>
    要传给静态方法的参数。</p>

<p>CallStatic[type]MethodA例程的其它参数： <br>
    args：参数数组。</p>

<p>CallStatic[type]MethodV例程的其它参数： <br>
    args：参数的va_list。</p>

<p>返回值： <br>
    返回调用静态Java方法的结果。</p>

<p>抛出： <br>
    执行Java方法时抛出的异常。</p>



<h3 id="字符串操作"><a name="t28"></a><a name="t28"></a>字符串操作</h3>



<h4 id="newstring-利用unicode字符数组构造新的javalangstring对象">NewString 利用Unicode字符数组构造新的java.lang.String对象。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jstring NewString(JNIEnv *env, <span class="hljs-keyword">const</span> jchar *unicodeChars, jsize len);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    unicodeChars：指向Unicode字符串的指针。 <br>
    len：Unicode字符串的长度。</p>

<p>返回值： <br>
    Java字符串对象。如果无法构造该字符串，则为NULL。</p>

<p>抛出： <br>
    OutOfMemoryError：如果系统内存不足。</p>



<h4 id="getstringlength-返回java字符串的长度unicode字符数">GetStringLength 返回Java字符串的长度（Unicode字符数）。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jsize GetStringLength(JNIEnv *env, jstring <span class="hljs-built_in">string</span>);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    string：Java字符串对象。</p>

<p>返回值： <br>
    Java 字符串的长度。</p>



<h4 id="getstringchars-返回指向字符串的unicode字符数组的指针该指针在调用releasestringchars前一直有效如果iscopy非空则在复制完成后将iscopy设为jnitrue如果没有复制则设为jnifalse">GetStringChars 返回指向字符串的Unicode字符数组的指针。该指针在调用ReleaseStringchars()前一直有效。如果isCopy非空，则在复制完成后将*isCopy设为JNI_TRUE。如果没有复制，则设为JNI_FALSE。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">const</span> jchar * GetStringChars(JNIEnv *env, jstring <span class="hljs-built_in">string</span>, jboolean *isCopy);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    string：Java字符串对象。 <br>
    isCopy：指向布尔值的指针。</p>

<p>返回值： <br>
    指向Unicode字符串的指针，如果操作失败，则返回NULL。</p>



<h4 id="releasestringchars-通知虚拟机平台相关代码无需再访问chars参数chars是一个指针可通过getstringchars从string获得">ReleaseStringChars 通知虚拟机平台相关代码无需再访问chars。参数chars是一个指针，可通过GetStringChars()从string获得。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> ReleaseStringChars(JNIEnv *env, jstring <span class="hljs-built_in">string</span>, <span class="hljs-keyword">const</span> jchar *chars);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    string：Java字符串对象。 <br>
    chars：指向Unicode字符串的指针。</p>



<h4 id="newstringutf-利用utf-8字符数组构造新javalangstring对象">NewStringUTF 利用UTF-8字符数组构造新java.lang.String对象。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jstring NewStringUTF(JNIEnv *env, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *bytes);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。如果无法构造该字符串，则为NULL。 <br>
    bytes：指向UTF-8字符串的指针。</p>

<p>返回值： <br>
    Java字符串对象。如果无法构造该字符串，则为NULL。</p>

<p>抛出： <br>
    OutOfMemoryError：如果系统内存不足。</p>



<h4 id="getstringutflength-以字节为单位返回字符串的utf-8长度">GetStringUTFLength 以字节为单位返回字符串的UTF-8长度。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jsize GetStringUTFLength(JNIEnv *env, jstring <span class="hljs-built_in">string</span>);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    string：Java字符串对象。</p>

<p>返回值： <br>
    返回字符串的UTF-8长度。</p>



<h4 id="getstringutfchars-返回指向字符串的utf-8字符数组的指针该数组在被releasestringutfchars释放前将一直有效如果iscopy不是nulliscopy在复制完成后即被设为jnitrue如果未复制则设为jnifalse">GetStringUTFChars 返回指向字符串的UTF-8字符数组的指针。该数组在被ReleaseStringUTFChars()释放前将一直有效。如果isCopy不是NULL，*isCopy在复制完成后即被设为JNI_TRUE。如果未复制，则设为JNI_FALSE。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* GetStringUTFChars(JNIEnv *env, jstring <span class="hljs-built_in">string</span>, jboolean *isCopy);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    string：Java字符串对象。 <br>
    isCopy：指向布尔值的指针。</p>

<p>返回值： <br>
    指向UTF-8字符串的指针。如果操作失败，则为NULL。</p>



<h4 id="releasestringutfchars-通知虚拟机平台相关代码无需再访问utfutf参数是一个指针可利用getstringutfchars从string获得">ReleaseStringUTFChars 通知虚拟机平台相关代码无需再访问utf。utf参数是一个指针，可利用GetStringUTFChars()从string获得。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> ReleaseStringUTFChars(JNIEnv *env, jstring <span class="hljs-built_in">string</span>, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *utf);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    string：Java字符串对象。 <br>
    utf：指向UTF-8字符串的指针。</p>



<h3 id="数组操作"><a name="t29"></a><a name="t29"></a>数组操作</h3>



<h4 id="getarraylength-返回数组中的元素数">GetArrayLength 返回数组中的元素数。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jsize GetArrayLength(JNIEnv *env, jarray <span class="hljs-built_in">array</span>);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    array：Java数组对象。</p>

<p>返回值： <br>
    数组的长度。</p>



<h4 id="newobjectarray-构造新的数组它将保存类elementclass中的对象所有元素初始值均设为initialelement">NewObjectArray 构造新的数组，它将保存类elementClass中的对象。所有元素初始值均设为initialElement。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jarray NewObjectArray(JNIEnv *env, jsize length, jclass elementClass, jobject initialElement);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    length：数组大小。 <br>
    elementClass：数组元素类。 <br>
    initialElement：初始值。</p>

<p>返回值： <br>
    Java数组对象。如果无法构造数组，则为NULL。</p>

<p>抛出： <br>
    OutOfMemoryError：如果系统内存不足。</p>



<h4 id="getobjectarrayelement-返回object数组的元素">GetObjectArrayElement 返回Object数组的元素。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jobject GetObjectArrayElement(JNIEnv *env, jobjectArray <span class="hljs-built_in">array</span>, jsize index);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    array：Java数组。 <br>
    index：数组下标。</p>

<p>返回值： <br>
    Java对象。</p>

<p>抛出： <br>
    ArrayIndexOutOfBoundsException：如果index不是数组中的有效下标。</p>



<h4 id="setobjectarrayelement-设置object数组的元素">SetObjectArrayElement 设置Object数组的元素。</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> SetObjectArrayElement(JNIEnv *env, jobjectArray <span class="hljs-built_in">array</span>, jsize index, jobject value);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    array：Java数组。 <br>
    index：数组下标。 <br>
    value：新值。</p>

<p>抛出： <br>
    ArrayIndexOutOfBoundsException：如果index不是数组中的有效下标。 <br>
    ArrayStoreException：如果value的类不是数组元素类的子类。</p>



<h4 id="newprimitivetypearray例程">New[PrimitiveType]Array例程</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">ArrayType New&lt;PrimitiveType&gt;Array(JNIEnv *env, jsize length);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>用于构造新基本类型数组对象的一系列操作。下表说明了特定的基本类型数组构造函数。用户应把New[PrimitiveType]Array替换为 <br>
某个实际的基本类型数组构造函数例程名（见下表），然后将ArrayType替换为该例程相应的数组类型。</p>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>New[PrimitiveType]Array例程</em></th>
  <th align="left"><em>数组类型</em></th>
</tr>
</thead>
<tbody><tr>
  <td>NewBooleanArray()</td>
  <td align="left">jbooleanArray</td>
</tr>
<tr>
  <td>NewByteArray()</td>
  <td align="left">jbyteArray</td>
</tr>
<tr>
  <td>NewCharArray()</td>
  <td align="left">jcharArray</td>
</tr>
<tr>
  <td>NewShortArray()</td>
  <td align="left">jshortArray</td>
</tr>
<tr>
  <td>NewIntArray()</td>
  <td align="left">jintArray</td>
</tr>
<tr>
  <td>NewLongArray()</td>
  <td align="left">jlongArray</td>
</tr>
<tr>
  <td>NewFloatArray()</td>
  <td align="left">jfloatArray</td>
</tr>
<tr>
  <td>NewDoubleArray()</td>
  <td align="left">jdoubleArray</td>
</tr>
</tbody></table></div>


<p>参数： <br>
    env：JNI接口指针。 <br>
    length：数组长度。</p>

<p>返回值： <br>
    Java数组。如果无法构造该数组，则为NULL。</p>



<h4 id="getprimitivetypearrayelements例程">Get[PrimitiveType]ArrayElements例程</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">NativeType *Get&lt;PrimitiveType&gt;ArrayElements(JNIEnv *env, ArrayType <span class="hljs-built_in">array</span>, jboolean *isCopy);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>一组返回基本类型数组体的函数。结果在调用相应的Release[PrimitiveType]ArrayElements()函数前将一直有效。由于返回的数组可能是Java数组的副本，因此对返回数组的更改不必在基本类型数组中反映出来，直到调用了Release[PrimitiveType]ArrayElements()。如果isCopy不是NULL，*isCopy在复制完成后即被设为JNI_TRUE。如果未复制，则设为JNI_FALSE。</p>

<p>下表说明了特定的基本类型数组元素访问器。应进行下列替换；</p>

<ol>
<li>将Get[PrimitiveType]ArrayElements替换为表中某个实际的基本类型元素访问器例程名。</li>
<li>将ArrayType替换为对应的数组类型。</li>
<li>将NativeType替换为该例程对应的本地类型。</li>
</ol>

<p>不管布尔数组在Java虚拟机中如何表示，GetBooleanArrayElements()将始终返回一个jbooleans类型的指针，其中每一字节代表一个元素（开包表示）。内存中将确保所有其它类型的数组为连续的。</p>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>Get[PrimitiveType]ArrayElements例程</em></th>
  <th align="left"><em>数组类型</em></th>
  <th align="left"><em>本地类型</em></th>
</tr>
</thead>
<tbody><tr>
  <td>GetBooleanArrayElements()</td>
  <td align="left">jbooleanArray</td>
  <td align="left"></td>
</tr>
<tr>
  <td>GetByteArrayElements()</td>
  <td align="left">jbyteArray</td>
  <td align="left"></td>
</tr>
<tr>
  <td>GetCharArrayElements()</td>
  <td align="left">jcharArray</td>
  <td align="left"></td>
</tr>
<tr>
  <td>GetShortArrayElements()</td>
  <td align="left">jshortArray</td>
  <td align="left"></td>
</tr>
<tr>
  <td>GetIntArrayElements()</td>
  <td align="left">jintArray</td>
  <td align="left"></td>
</tr>
<tr>
  <td>GetLongArrayElements()</td>
  <td align="left">jlongArray</td>
  <td align="left"></td>
</tr>
<tr>
  <td>GetFloatArrayElements()</td>
  <td align="left">jfloatArray</td>
  <td align="left"></td>
</tr>
<tr>
  <td>GetDoubleArrayElements()</td>
  <td align="left">jdoubleArray</td>
  <td align="left"></td>
</tr>
</tbody></table></div>


<p>参数： <br>
    env：JNI接口指针。 <br>
    array：Java字符串对象。 <br>
    isCopy：指向布尔值的指针。</p>

<p>返回值： <br>
    返回指向数组元素的指针，如果操作失败，则为NULL。</p>



<h4 id="releaseprimitivetypearrayelements例程">Release[PrimitiveType]ArrayElements例程</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> Release&lt;PrimitiveType&gt;ArrayElements(JNIEnv *env, ArrayType <span class="hljs-built_in">array</span>, NativeType *elems, jint mode);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>通知虚拟机平台相关代码无需再访问elems的一组函数。elems参数是一个通过使用对应的Get[PrimitiveType]ArrayElements()函数由array导出的指针。必要时，该函数将把对elems的修改复制回基本类型数组。mode参数将提供有关如何释放数组缓冲区的信息。如果elems不是array中数组元素的副本，mode将无效。否则，mode将具有下表所述的功能：</p>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>基本类型数组释放模</em></th>
  <th align="left"><em>动作</em></th>
</tr>
</thead>
<tbody><tr>
  <td>0</td>
  <td align="left">复制回内容并释放elems缓冲区</td>
</tr>
<tr>
  <td>JNI_COMMIT</td>
  <td align="left">复制回内容但不释放elems缓冲区</td>
</tr>
<tr>
  <td>JNI_ABORT</td>
  <td align="left">释放缓冲区但不复制回变化</td>
</tr>
</tbody></table></div>


<p><br>
多数情况下，编程人员将把“0”传给mode参数以确保固定的数组和复制的数组保持一致。其它选项可以使编程人员进一步控制内存管理，但使用时务必慎重。下表说明了构成基本类型数组撤消程序系列的特定例程。应进行如下替换；</p>

<ol>
<li>将Release[PrimitiveType]ArrayElements 替换为下表中的某个实际基本类型数组撤消程序例程名。</li>
<li>将ArrayType替换为对应的数组类型。</li>
<li>将NativeType替换为该例程对应的本地类型。</li>
</ol>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>ReleaseArrayElements例程</em></th>
  <th align="left"><em>数组类型</em></th>
  <th align="left"><em>本地类型</em></th>
</tr>
</thead>
<tbody><tr>
  <td>ReleaseBooleanArrayElements()</td>
  <td align="left">jbooleanArray</td>
  <td align="left">jboolean</td>
</tr>
<tr>
  <td>ReleaseByteArrayElements()</td>
  <td align="left">jbyteArray</td>
  <td align="left">jbyte</td>
</tr>
<tr>
  <td>ReleaseCharArrayElements()</td>
  <td align="left">jcharArray</td>
  <td align="left">jchar</td>
</tr>
<tr>
  <td>ReleaseShortArrayElements()</td>
  <td align="left">jshortArray</td>
  <td align="left">jshort</td>
</tr>
<tr>
  <td>ReleaseIntArrayElements()</td>
  <td align="left">jintArray</td>
  <td align="left">jint</td>
</tr>
<tr>
  <td>ReleaseLongArrayElements()</td>
  <td align="left">jlongArray</td>
  <td align="left">jlong</td>
</tr>
<tr>
  <td>ReleaseFloatArrayElements()</td>
  <td align="left">jfloatArray</td>
  <td align="left">jfloat</td>
</tr>
<tr>
  <td>ReleaseDoubleArrayElements()</td>
  <td align="left">jdoubleArray</td>
  <td align="left">jdouble</td>
</tr>
</tbody></table></div>


<p>参数： <br>
    env：JNI接口指针。 <br>
    array：Java数组对象。 <br>
    elems：指向数组元素的指针。 <br>
    mode：释放模式。</p>



<h4 id="getprimitivetypearrayregion例程">Get[PrimitiveType]ArrayRegion例程</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> Get&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType <span class="hljs-built_in">array</span>, jsize start, jsize len, NativeType *buf);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>将基本类型数组某一区域复制到缓冲区中的一组函数。下表说明了特定的基本类型数组元素访问器。应进行如下替换：</p>

<ol>
<li>将Get[PrimitiveType]ArrayRegion替换为表中的某个实际基本类型元素访问器例程名。</li>
<li>将 ArrayType 替换为对应的数组类型。</li>
<li>将 NativeType 替换为该例程对应的本地类型。</li>
</ol>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>Get[PrimitiveType]ArrayRegion例程</em></th>
  <th align="left"><em>数组类型</em></th>
  <th align="left"><em>本地类型</em></th>
</tr>
</thead>
<tbody><tr>
  <td>GetBooleanArrayRegion()</td>
  <td align="left">jbooleanArray</td>
  <td align="left">jboolean</td>
</tr>
<tr>
  <td>GetByteArrayRegion()</td>
  <td align="left">jbyteArray</td>
  <td align="left">jbyte</td>
</tr>
<tr>
  <td>GetCharArrayRegion()</td>
  <td align="left">jcharArray</td>
  <td align="left">jchar</td>
</tr>
<tr>
  <td>GetShortArrayRegion()</td>
  <td align="left">jshortArray</td>
  <td align="left">jshort</td>
</tr>
<tr>
  <td>GetIntArrayRegion()</td>
  <td align="left">jintArray</td>
  <td align="left">jint</td>
</tr>
<tr>
  <td>GetLongArrayRegion()</td>
  <td align="left">jlongArray</td>
  <td align="left">jlong</td>
</tr>
<tr>
  <td>GetFloatArrayRegion()</td>
  <td align="left">jfloatArray</td>
  <td align="left">jfloat</td>
</tr>
<tr>
  <td>GetDoubleArrayRegion()</td>
  <td align="left">jdoubleArray</td>
  <td align="left">jdouble</td>
</tr>
</tbody></table></div>


<p>参数： <br>
    env：JNI接口指针。 <br>
    array：Java指针。 <br>
    start：起始下标。 <br>
    len：要复制的元素数。 <br>
    buf：目的缓冲区。</p>

<p>抛出： <br>
    ArrayIndexOutOfBoundsException：如果区域中的某个下标无效。</p>



<h4 id="setprimitivetypearrayregion例程">Set[PrimitiveType]ArrayRegion例程</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">void</span> Set&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType <span class="hljs-built_in">array</span>, jsize start, jsize len, NativeType *buf);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>将基本类型数组的某一区域从缓冲区中复制回来的一组函数。下表说明了特定的基本类型数组元素访问器。应进行如下替换：</p>

<ol>
<li>将Set[PrimitiveType]ArrayRegion替换为表中的实际基本类型元素访问器例程名。</li>
<li>将ArrayType替换为对应的数组类型。</li>
<li>将NativeType替换为该例程对应的本地类型。    </li>
</ol>

<div class="table-box"><table>
<thead>
<tr>
  <th><em>Set[PrimitiveType]ArrayRegion例程</em></th>
  <th align="left"><em>数组类型</em></th>
  <th align="left"><em>本地类型</em></th>
</tr>
</thead>
<tbody><tr>
  <td>SetBooleanArrayRegion()</td>
  <td align="left">jbooleanArray</td>
  <td align="left">jboolean</td>
</tr>
<tr>
  <td>SetByteArrayRegion()</td>
  <td align="left">jbyteArray</td>
  <td align="left">jbyte</td>
</tr>
<tr>
  <td>SetCharArrayRegion()</td>
  <td align="left">jcharArray</td>
  <td align="left">jchar</td>
</tr>
<tr>
  <td>SetShortArrayRegion()</td>
  <td align="left">jshortArray</td>
  <td align="left">jshort</td>
</tr>
<tr>
  <td>SetIntArrayRegion()</td>
  <td align="left">jintArray</td>
  <td align="left">jint</td>
</tr>
<tr>
  <td>SetLongArrayRegion()</td>
  <td align="left">jlongArray</td>
  <td align="left">jlong</td>
</tr>
<tr>
  <td>SetFloatArrayRegion()</td>
  <td align="left">jfloatArray</td>
  <td align="left">jfloat</td>
</tr>
<tr>
  <td>SetDoubleArrayRegion()</td>
  <td align="left">jdoubleArray</td>
  <td align="left">jdouble</td>
</tr>
</tbody></table></div>


<p><br>
参数： <br>
    env：JNI接口指针。 <br>
    array: Java数组。 <br>
    start：起始下标。 <br>
    len：要复制的元素数。 <br>
    buf：源缓冲区。</p>

<p>抛出： <br>
    ArrayIndexOutOfBoundsException：如果区域中的某个下标无效。    </p>



<h3 id="注册本地方法"><a name="t30"></a><a name="t30"></a>注册本地方法</h3>



<h4 id="registernatives">RegisterNatives</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint RegisterNatives(JNIEnv *env, jclass clazz, <span class="hljs-keyword">const</span> JNINativeMethod *methods, jint nMethods);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>向clazz参数指定的类注册本地方法。methods参数将指定JNINativeMethod结构的数组，其中包含本地方法的名称、签名和函数指针。nMethods参数将指定数组中的本地方法数。JNINativeMethod 结构定义如下所示：</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> {
    <span class="hljs-keyword">char</span> *name;
    <span class="hljs-keyword">char</span> *signature;
    <span class="hljs-keyword">void</span> *fnPtr;
} JNINativeMethod;</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre>

<p>函数指针通常必须有下列签名：</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">ReturnType (*fnPtr)(JNIEnv *env, jobject objectOrClass, ...);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类对象。 <br>
    methods：类中的本地方法。 <br>
    nMethods：类中的本地方法数。</p>

<p>返回值： <br>
    成功时返回 “0”；失败时返回负数。</p>

<p>抛出： <br>
    NoSuchMethodError：如果找不到指定的方法或方法不是本地方法。</p>



<h4 id="unregisternatives">UnregisterNatives</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint UnregisterNatives(JNIEnv *env, jclass clazz);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>取消注册类的本地方法。类将返回到链接或注册了本地方法函数前的状态。该函数不应在常规平台相关代码中使用。相反，它可以为某些程序提供一种重新加载和重新链接本地库的途径。</p>

<p>参数： <br>
    env：JNI接口指针。 <br>
    clazz：Java类对象。</p>

<p>返回值： <br>
    成功时返回“0”；失败时返回负数。   </p>



<h3 id="监视程序操作"><a name="t31"></a><a name="t31"></a>监视程序操作</h3>



<h4 id="monitorenter">MonitorEnter</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint MonitorEnter(JNIEnv *env, jobject obj);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>进入与obj所引用的基本Java对象相关联的监视程序。每个Java对象都有一个相关联的监视程序。如果当前线程已经拥有与obj相关联的监视程序，它将使指示该线程进入监视程序次数的监视程序计数器增 1。如果与 obj 相关联的监视程序并非由某个线程所拥有，则当前线程将变为该监视程序的所有者，同时将该监视程序的计数器设置为 1。如果另一个线程已拥有与 obj 关联的监视程序，则在监视程序被释放前当前线程将处于等待状态。监视程序被释放后，当前线程将尝试重新获得所有权。</p>

<p>参数： <br>
    env：JNI接口指针。 <br>
    obj：常规Java对象或类对象。</p>

<p>返回值： <br>
    成功时返回“0”；失败时返回负数。</p>



<h4 id="monitorexit">MonitorExit</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint MonitorExit(JNIEnv *env, jobject obj);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>当前线程必须是与obj所引用的基本Java对象相关联的监视程序的所有者。线程将使指示进入监视程序次数的计数器减 1。如果计数器的值变为 0，当前线程释放监视程序。</p>

<p>参数： <br>
    env：JNI接口指针。 <br>
    obj：常规Java对象或类对象。</p>

<p>返回值： <br>
    成功时返回“0”；失败时返回负数。</p>



<h3 id="java虚拟机接口"><a name="t32"></a><a name="t32"></a>Java虚拟机接口</h3>



<h4 id="getjavavm">GetJavaVM</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint GetJavaVM(JNIEnv *env, JavaVM **vm);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>返回与当前线程相关联的Java虚拟机接口（用于调用API中）。结果将放在第二个参数vm所指向的位置。</p>

<p>参数： <br>
    env：JNI接口指针。 <br>
    vm：指向放置结果的位置的指针。</p>

<p>返回值： <br>
    成功时返回“0”；失败时返回负数。</p>

<hr>



<h2 id="调用api"><a name="t33"></a><a name="t33"></a>调用API</h2>

<p>调用API允许软件厂商将Java虚拟机加载到任意的本地程序中。厂商可以交付支持Java的应用程序，而不必链接Java虚拟机源代码。本章首先概述了调用API。然后是所有调用API函数的引用页。若要增强Java虚拟机的嵌入性，可以用几种方式来扩展JDK 1.1.2中的调用API。</p>



<h3 id="概述"><a name="t34"></a><a name="t34"></a>概述</h3>

<p>以下代码示例说明了如何使用调用API中的函数。在本例中，C++代码创建Java虚拟机并且调用名为Main.test的静态方法。为清楚起见，我们略去了错误检查。</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">    <span class="hljs-preprocessor">#include &lt;jni.h&gt;</span>
    <span class="hljs-comment">/* 其中定义了所有的事项 */</span>
    ...
    JavaVM *jvm;
    <span class="hljs-comment">/* 表示 Java 虚拟机*/</span>
    JNIEnv *env;
    <span class="hljs-comment">/* 指向本地方法接口的指针 */</span>
    JDK1_1InitArgs vm_args; <span class="hljs-comment">/* JDK 1.1 虚拟机初始化参数 */</span>
    vm_args.version = <span class="hljs-number">0x00010001</span>; <span class="hljs-comment">/* 1.1.2 中新增的：虚拟机版本 */</span>
    <span class="hljs-comment">/* 获得缺省的初始化参数并且设置类路径 */</span>
    JNI_GetDefaultJavaVMInitArgs(&amp;vm_args);
    vm_args.classpath = ...;
    <span class="hljs-comment">/* 加载并初始化 Java 虚拟机，返回env中的JNI 接口指针 */</span>
    JNI_CreateJavaVM(&amp;jvm, &amp;env, &amp;vm_args);
    <span class="hljs-comment">/* 用 JNI 调用 Main.test 方法 */</span>
    jclass cls = env-&gt;FindClass(<span class="hljs-string">"Main"</span>);
    jmethodID mid = env-&gt;GetStaticMethodID(cls, <span class="hljs-string">"test"</span>, <span class="hljs-string">"(I)V"</span>);
    env-&gt;CallStaticVoidMethod(cls, mid, <span class="hljs-number">100</span>);
    <span class="hljs-comment">/* 结束。*/</span>
    jvm-&gt;DestroyJavaVM();</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li></ul></pre>

<p>本例使用了API中的三个函数。调用API允许本地应用程序用JNI接口指针来访问虚拟机特性。其设计类似于Netscape的JRI嵌入式接口。</p>



<h4 id="创建虚拟机">创建虚拟机</h4>

<p>JNI_CreateJavaVM()函数加载并初始化Java虚拟机，然后将指针返回到JNI接口指针。调用JNI_CreateJavaVM()的线程被看作主线程。</p>



<h4 id="连接虚拟机">连接虚拟机</h4>

<p>JNI接口指针(JNIEnv)仅在当前线程中有效。如果另一个线程需要访问Java虚拟机，则该线程首先必须调用AttachCurrentThread()以将自身连接到虚拟机并且获得JNI接口指针。连接到虚拟机之后，本地线程的工作方式就与在本地方法内运行的普通Java线程一样了。本地线程保持与虚拟机的连接，直到调用DetachCurrentThread()时才断开连接。</p>



<h4 id="卸载虚拟机">卸载虚拟机</h4>

<p>主线程不能自己断开与虚拟机的连接。而是必须调用DestroyJavaVM()来卸载整个虚拟机。</p>

<p>虚拟机等到主线程成为唯一的用户线程时才真正地卸载。用户线程包括Java线程和附加的本地线程。之所以存在这种限制是因为Java线程或附加的本地线程可能正占用着系统资源，例如锁，窗口等。虚拟机不能自动释放这些资源。卸载虚拟机时，通过将主线程限制为唯一的运行线程，使释放任意线程所占用系统资源的负担落到程序员身上。</p>



<h3 id="初始化结构"><a name="t35"></a><a name="t35"></a>初始化结构</h3>

<p>不同的Java虚拟机实现可能会需要不同的初始化参数。很难提出适合于所有现有和将来的Java虚拟机的标准初始化结构。作为一种折衷方式，我们保留了第一个域(version)来识别初始化结构的内容。嵌入到JDK 1.1.2中的本地应用程序必须将版本域设置为0x00010001。尽管其它实现可能会忽略某些由JDK所支持的初始化参数，我们仍然鼓励虚拟机实现使用与JDK一样的初始化结构。0x80000000到0xFFFFFFFF之间的版本号需保留，并且不为任何虚拟机实现所识别。</p>

<p>以下代码显示了初始化JDK 1.1.2中的Java虚拟机所用的结构。</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> JavaVMInitArgs {
    <span class="hljs-comment">/* 前两个域在 JDK 1.1 中保留，并在 JDK 1.1.2 中正式引入。*/</span>
    <span class="hljs-comment">/* Java 虚拟机版本 */</span>
    jint version;
    <span class="hljs-comment">/* 系统属性。*/</span>
    <span class="hljs-keyword">char</span> **properties;
    <span class="hljs-comment">/* 是否检查 Java 源文件与已编译的类文件之间的新旧关系。*/</span>
    jint checkSource;
    <span class="hljs-comment">/* Java 创建的线程的最大本地堆栈大小。*/</span>
    jint nativeStackSize;
    <span class="hljs-comment">/* 最大 Java 堆栈大小。*/</span>
    jint javaStackSize;
    <span class="hljs-comment">/* 初始堆大小。*/</span>
    jint minHeapSize;
    <span class="hljs-comment">/* 最大堆大小。*/</span>
    jint maxHeapSize;
    <span class="hljs-comment">/* 控制是否校验 Java 字节码：0 无，1 远程加载的代码，2 所有代码。*/</span>
    jint verifyMode;
    <span class="hljs-comment">/* 类加载的本地目录路径。*/</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *classpath;
    <span class="hljs-comment">/* 重定向所有虚拟机消息的函数的钩子。*/</span>
    jint (*<span class="hljs-built_in">vfprintf</span>)(FILE *fp, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *format, va_list args);
    <span class="hljs-comment">/* 虚拟机退出钩子。*/</span>
    <span class="hljs-keyword">void</span> (*<span class="hljs-built_in">exit</span>)(jint code);
    <span class="hljs-comment">/* 虚拟机放弃钩子。*/</span>
    <span class="hljs-keyword">void</span> (*<span class="hljs-built_in">abort</span>)();
    <span class="hljs-comment">/* 是否启用类 GC。*/</span>
    jint enableClassGC;
    <span class="hljs-comment">/* GC 消息是否出现。*/</span>
    jint enableVerboseGC;
    <span class="hljs-comment">/* 是否允许异步 GC。*/</span>
    jint disableAsyncGC;
    <span class="hljs-comment">/* 三个保留的域。*/</span>
    jint reserved0;
    jint reserved1;
    jint reserved2;
} JDK1_1InitArgs;</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li></ul></pre>

<p>在JDK 1.1.2中，初始化结构提供了钩子，这样在虚拟机终止时，本地应用程序可以重定向虚拟机消息并获得控制权。当本地线程与JDK 1.1.2中的Java虚拟机连接时，以下结构将作为参数进行传递。实际上，本地线程与JDK 1.1.2连接时不需要任何参数。JDK1_1AttachArgs 结构仅由C编译器的填充槽组成，而C编译器不允许空结构。</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> JDK1_1AttachArgs {
    <span class="hljs-comment">/*
    * JDK 1.1 不需要任何参数来附加本地线程。此处填充的作用是为了满足不允许空结构的C编译器的要求。
    */</span>
    <span class="hljs-keyword">void</span> *__padding;
} JDK1_1AttachArgs;</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li></ul></pre>



<h3 id="调用api函数"><a name="t36"></a><a name="t36"></a>调用API函数</h3>

<p>JavaVM类型是指向调用API函数表的指针。以下代码示例显示了这种函数表。</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> JNIInvokeInterface *JavaVM;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> JNIInvokeInterface ... = {
    NULL,
    NULL,
    NULL,
    DestroyJavaVM,
    AttachCurrentThread,
    DetachCurrentThread,
};</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre>

<p>注意，JNI_GetDefaultJavaVMInitArgs()、JNI_GetCreatedJavaVMs()和JNI_CreateJavaVM() 这三个调用API函数不是JavaVM函数表的一部分。不必先有JavaVM结构，就可以使用这些函数。</p>



<h4 id="jnigetdefaultjavavminitargs">JNI_GetDefaultJavaVMInitArgs</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint JNI_GetDefaultJavaVMInitArgs(<span class="hljs-keyword">void</span> *vm_args);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>返回Java虚拟机的缺省配置。在调用该函数之前，平台相关代码必须将vm_args-&gt;version 域设置为它所期望虚拟机支持的JNI版本。在JDK 1.1.2中，必须将vm_args-&gt;version设置为0x00010001。（JDK 1.1不要求平台相关代码设置版本域。为了向后兼容性，如果没有设置版本域，则JDK 1.1.2假定所请求的版本为0x00010001。JDK的未来版本将要求把版本域设置为适当的值。）该函数返回后，将把vm_args-&gt;version设置为虚拟机支持的实际JNI版本。</p>

<p>参数： <br>
    vm_args：指向VM-specific initialization（特定于虚拟机的初始化）结构的指针，缺省参数填入该结构。</p>

<p>返回值： <br>
    如果所请求的版本得到支持，则返回“0”；如果所请求的版本未得到支持，则返回负数。</p>



<h4 id="jnigetcreatedjavavms">JNI_GetCreatedJavaVMs</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint JNI_GetCreatedJavaVMs(JavaVM **vmBuf, jsize bufLen, jsize *nVMs);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>返回所有已创建的Java虚拟机。将指向虚拟机的指针依据其创建顺序写入vmBuf缓冲区。最多写入bufLen项。在*nVMs中返回所创建虚拟机的总数。JDK 1.1不支持在单个进程中创建多个虚拟机。</p>

<p>参数： <br>
    vmBuf：指向将放置虚拟机结构的缓冲区的指针。 <br>
    bufLen：缓冲区的长度。 <br>
    nVMs：指向整数的指针。</p>

<p>返回值： <br>
    成功时返回“0”；失败则返回负数。</p>



<h4 id="jnicreatejavavm">JNI_CreateJavaVM</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint JNI_CreateJavaVM(JavaVM **p_vm, JNIEnv **p_env, <span class="hljs-keyword">void</span> *vm_args);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>加载并初始化Java虚拟机。当前线程成为主线程。将env参数设置为主线程的JNI接口指针。JDK 1.1.2不支持在单个进程中创建多个虚拟机。必须将vm_args中的版本域设置为0x00010001。</p>

<p>参数： <br>
    p_vm：指向位置（其中放置所得到的虚拟机结构）的指针。 <br>
    p_env：指向位置（其中放置主线程的 JNI 接口指针）的指针。 <br>
    vm_args: Java 虚拟机初始化参数。</p>

<p>返回值： <br>
    成功时返回“0”；失败则返回负数。</p>



<h4 id="destroyjavavm">DestroyJavaVM</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint DestroyJavaVM(JavaVM *vm);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>卸载Java虚拟机并回收资源。只有主线程能够卸载虚拟机。调用DestroyJavaVM() 时，主线程必须是唯一的剩余用户线程。</p>

<p>参数： <br>
    vm：将销毁的Java虚拟机。</p>

<p>返回值： <br>
    成功时返回“0”；失败则返回负数。</p>

<p>JDK 1.1.2 不支持卸载虚拟机。</p>



<h4 id="attachcurrentthread">AttachCurrentThread</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint AttachCurrentThread(JavaVM *vm, JNIEnv **p_env, <span class="hljs-keyword">void</span> *thr_args);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>将当前线程连接到Java虚拟机。在JNIEnv参数中返回JNI接口指针。试图连接已经连接的线程将不执行任何操作。本地线程不能同时连接到两个Java虚拟机上。</p>

<p>参数： <br>
    vm：当前线程所要连接到的虚拟机。 <br>
    p_env：指向位置（其中放置当前线程的 JNI 接口指针）的指针。 <br>
    thr_args：特定于虚拟机的线程连接参数。</p>

<p>返回值： <br>
    成功时返回“0”；失败则返回负数。</p>



<h4 id="detachcurrentthread">DetachCurrentThread</h4>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">jint DetachCurrentThread(JavaVM *vm);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li></ul></pre>

<p>断开当前线程与Java虚拟机之间的连接。释放该线程占用的所有Java监视程序。通知所有等待该线程终止的Java线程。主线程（即创建Java虚拟机的线程）不能断开与虚拟机之间的连接。作为替代，主线程必须调用JNI_DestroyJavaVM()来卸载整个虚拟机。</p>

<p>参数： <br>
    vm：当前线程将断开连接的虚拟机。</p>

<p>返回值： <br>
    成功时返回“0”；失败则返回负数。</p>



<h4 id="createfile">CreateFile</h4>

<p>(1)函数原型</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">HANDLE CreateFile(
    LPCTSTR lpfileName，
    DWORD deDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    DWORD dwCreationDesposition,
    DWORD dwFlagsAndAtrributes,
    HANDLE hTemplateFile
);</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre>

<p>(2)函数说明</p>

<p>该函数创建、打开或截断一个文件，并返回一个能够被用来存取该文件的句柄。此句柄允许读书据、写数据以及移动文件的指针。CreateFile函数既可以做为一个宽自负函数使用，也可以作为一个ANSI函数来用。</p>

<p>(3)参数说明</p>

<p>lpFileName:指向文件字符串的指针。 <br>
dwDesireAccess:制定文件的存取模式，可以取下列值： <br>
0:制定可以查询对象。 <br>
GENERIC_READ:指定可以从文件中度去数据。 <br>
GENERIC_WRITE:指定可以向文件中写数据。 <br>
dwShareMode:指定文件的共享模式，可以取下列值：</p>

<ol>
<li>0:不共享。</li>
<li>FILE_SHARE_DELETE:在 Windows NT 系统中，只有为了删除文件而进行的打开操作才会成功。</li>
<li>FILE_SHARE_READ:只有为了从文件中度去数据而进行的打开操作才会成功。</li>
<li>FILE_SHARE_WRITE:只有为了向文件中写数据而进行的打开操作才会成功。</li>
</ol>

<p>lpSecurityAttributes:指定文件的安全属性。 <br>
dwCreationDisopsition:指定创建文件的方式，可以取以下值：</p>

<ol>
<li>CREATE_NEW:创建新文件，如果文件已存在，则函数失败。</li>
<li>CREATE_ALWAYS:创建爱内心文件，如果文件已存在，则函数将覆盖并清除旧文件。</li>
<li>OPEN_EXISTING:打开文件，如果文件不存在，函数将失败。</li>
<li>OPEN_ALWAYS:打开文件，如果文件不存在，则函数将创建一个新文件。</li>
<li>TRUNCATE_EXISTING:打开外呢间，如果文件存在，函数将文件的大小设为零，如果文件不存在，函数将失败返回。</li>
</ol>

<p>dwFlagsAndAtrributes:指定新建文件的属性和标志，它可以取以下值： <br>
1. FILE_ATTRIBUTE_ARCHIVE:归档属性。 <br>
2. FILE_ATTRIBUTE_HIDDEN:隐藏属性。 <br>
3. FILE_ATTRIBUTE_NORMAL:正常属性。 <br>
4. FILE_ATTRIBUTE_READONLY:只读属性。 <br>
5. FILE_ATTRIBUTE_SYSTEM:系统文件。 <br>
6. FILE_ATTRIBUTE_TEMPORARY:临时存储文件，系统总是将临时文件的所有数据读入内存中，以加速对该文件的访问速度。用户应该尽快删除不再使用的临时文件。 <br>
7. FILE_FLAG_OVERLAPPED:用户可以通过一个 OVERLAPPED 结构变量来保存和设置文件读写指针，从而可以完成重叠式的读和写。一般用于数量比较大的读些操作。</p>

<p>hTemplateFile:指向一个具有GENERIC_READ属性的文件的句柄，该文件为要创建的文件提供文件属性和文件扩展属性。</p>

<p>(4)注意事项</p>

<p>函数成功将返回指定文件的句柄，否则返回NULL。</p>

<p>(5)典型示例：</p>



<pre class="prettyprint" name="code"><code class="language-c hljs  has-numbering">    ...
    <span class="hljs-keyword">char</span> szFile[<span class="hljs-number">64</span>];
    HANDLE handle;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> lWritten,lRead;

    handle = CreateFile(<span class="hljs-string">"c:\\windows\\desktop\\example.txt"</span>,GENERIC_READ|GENERIC_W
                        RITE,FILE_SHARE_READ,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,<span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span>(handle==INVALID_HANDLE_VALUE){
        MessageBox(NULL,<span class="hljs-string">"Error Create File!"</span>,<span class="hljs-string">"Error"</span>,MB_OK);
        <span class="hljs-keyword">break</span>;
    }<span class="hljs-keyword">else</span>
        MessageBox(NULL,<span class="hljs-string">"Open file Success!"</span>,<span class="hljs-string">"Open file"</span>,MB_OK);
</code><ul class="pre-numbering"><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li></ul></pre>

<hr>



<h2 id="总结"><a name="t37"></a><a name="t37"></a>总结</h2>

<p>至此整个JNI完全手册引用结束。日后开发过程中该手册相当于一本字典，可以用来查阅。</p>

<p>感谢原中文版手册作者，Admire，向大牛致敬，向开源致敬！</p>

<p>【工匠若水 <a href="http://blog.csdn.net/yanbober" target="_blank" rel="nofollow">http://blog.csdn.net/yanbober</a>】 继续阅读《NDK-JNI实战教程（三） 从一个比Hello World稍微复杂一丁点儿的例子说说模板》 <a href="http://blog.csdn.net/yanbober/article/details/45310589" target="_blank" rel="nofollow">http://blog.csdn.net/yanbober/article/details/45310589</a></p>                                    </div>
                <link href="https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-b6c3c6d139.css" rel="stylesheet">
                                    <div class="more-toolbox">
                <div class="left-toolbox">
                    <ul class="toolbox-list">
                        
                        <li class="tool-item tool-active is-like "><a href="javascript:;"><svg xmlns="http://www.w3.org/2000/svg" class="icon" aria-hidden="true">
                            <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#csdnc-thumbsup" />
                        </svg><span class="name">点赞</span>
                        <span class="count">11</span>
                        </a></li>
                        <li class="tool-item tool-active is-collection "><a href="javascript:;" data-report-click='{"mod":"popu_824"}'><svg xmlns="http://www.w3.org/2000/svg" class="icon" aria-hidden="true">
                            <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#icon-csdnc-Collection-G" />
                        </svg><span class="name">收藏</span></a></li>
                        <li class="tool-item tool-active is-share"><a href="javascript:;"><svg xmlns="http://www.w3.org/2000/svg" class="icon" aria-hidden="true">
                            <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#icon-csdnc-fenxiang" />
                        </svg>分享</a></li>
                        <!--打赏开始-->
                                                <!--打赏结束-->
                                                <li class="tool-item tool-more">
                            <a>
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 1024 1024" width="200" height="200" version="1.1" p-id="5717" t="1575545411852"><defs><style type="text/css" /></defs><path d="M 179.176 499.222 m -113.245 0 a 113.245 113.245 0 1 0 226.49 0 a 113.245 113.245 0 1 0 -226.49 0 Z" p-id="5718" /><path d="M 509.684 499.222 m -113.245 0 a 113.245 113.245 0 1 0 226.49 0 a 113.245 113.245 0 1 0 -226.49 0 Z" p-id="5719" /><path d="M 846.175 499.222 m -113.245 0 a 113.245 113.245 0 1 0 226.49 0 a 113.245 113.245 0 1 0 -226.49 0 Z" p-id="5720" /></svg>
                            </a>
                            <ul class="more-box">
                                <li class="item"><a class="article-report">文章举报</a></li>
                            </ul>
                        </li>
                                            </ul>
                </div>
                            </div>
            <div class="person-messagebox">
                <div class="left-message"><a href="https://blog.csdn.net/yanbober">
                    <img class="avatar_pic" src="images/android03604.jpg" username="yanbober">
                                            <img class="user-years" src="images/android03605.png">
                                    </a></div>
                <div class="middle-message">
                                        <div class="title"><span class="tit"><a href="https://blog.csdn.net/yanbober" target="_blank" data-report-click='{"mod":"popu_379"}'>工匠若水</a></span>
                                                    <span class="flag expert">
                                <a href="https://blog.csdn.net/home/help.html#classicfication" target="_blank">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="icon" aria-hidden="true">
                                        <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#csdnc-blogexpert" />
                                    </svg>
                                    博客专家
                                </a>
                            </span>
                                            </div>
                    <div class="text"><span>发布了107 篇原创文章</span> · <span>获赞 303</span> · <span>访问量 213万+</span></div>
                </div>
                                <div class="right-message">
                                            <a class="btn btn-sm btn-red-hollow bt-button personal-messageboard" href="https://bbs.csdn.net/forums/p-yanbober" target="_blank">他的留言板
                        </a>
                                                            <a class="btn btn-sm  bt-button personal-watch" data-report-click='{"mod":"popu_379"}'>关注</a>
                                    </div>
                            </div>
                    </div>


</div>


</body></html>