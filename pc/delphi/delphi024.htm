<html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Delphi2007升级到Delphi 2010总结 - weixin_30667649的博客 - CSDN博客</title>
  <link href="images/style.css" rel="stylesheet">
</head>

<body class="stackedit"><div class="stackedit__html">

<div class="article_content clearfix" id="article_content" style="overflow: hidden;">
                                        <div class="article-source-link">
                    原文链接：<a href="http://www.cnblogs.com/zerovirs/p/6791342.html" target="_blank" rel="noopener">http://www.cnblogs.com/zerovirs/p/6791342.html</a>
                </div>
                        <link href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css" rel="stylesheet">
                                        <link href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-3019150162.css" rel="stylesheet">
                <div class="htmledit_views" id="content_views">
                                            <div class="blogpost-body" id="cnblogs_post_body"><p><span><span>这两天把一个使用Delphi2007成功升级到了Delphi2010。升级途中很艰辛，总结了 以下经验与大家分享。另外，D7使用的第三方组件，由于官方没有发布For Delphi2010的更新，修改的第三 方组件列表见文章尾部。<br><br><span><span>1，PChar<br>因为Delphi不支持无类型指针的算术运算，很多程序员使用 PChar来代替Pointer，即使指针指向目标并不是PAnsiChar。<br><br>考虑如下代码：<br><br>var&nbsp;<br>&nbsp;&nbsp; P:PChar;<br>&nbsp;&nbsp; Buffer:Pointer;<br>begin<br>&nbsp;&nbsp; GetMem(Buffer,255);<br>&nbsp;&nbsp; P:=Buffer;<br>&nbsp;&nbsp; p^:=#1;<br>&nbsp;&nbsp; Inc(P);<br>&nbsp;&nbsp; p^:=#2;<br>&nbsp;&nbsp; FreeMem(Buffer,255);<br>end;<br>在2010中PChar已经不再表示PAnsiChar而是表示PWideChar，如果依然这样写，运行时很可能会得到一个内存访问错误。因为每 次Inc(P)，实际上指针向前移动了2字节，因为SizeOf(WideChar)=2，Inc(P)相当于 P:=P+SizeOf(WideChar)。<br><br>解决方法是把PChar替换成PAnsiChar&nbsp;<br><br><br><br>2，Move FillChar CopyMemory<br>这些函数依赖的是字节长度，往往我们直接使用Length(Str)来获取，这是行不通的。<br><br>考虑如下代码：<br><br>var<br>&nbsp;&nbsp; P1,P2:String;<br>begin<br>&nbsp;&nbsp; P1:='test';<br>&nbsp;&nbsp; SetLength(P2,Length(P1));<br>&nbsp;&nbsp; Move(P1[1],P2[1],Length(P1));<br>在2010中String默认映射到UnicodeString，单个字符是2字节，所以上文中P1实际占用了8字节内存，而传给Move函数的长 度只有4字节，最终结果是P2="te"。<br><br>解决办法1：<br><br>修改String为AnsiString，该方案虽然可行，但你的程序就享受不到Unicode待遇了。<br><br>解决办法2：<br><br>SetLength 函数不要修改，因为他的长度参数是字符长度，而不是字节长度。<br><br>Move函数的最后一个参数 Length(P1) 修改成 Length(P1)*SizeOf(Char)。<br><br>注意：不要偷懒使用万一老师说的ByteLength函数，该函数并没有For AnsiString的重载，编译器会 把参数隐式转化为UnicodeString然后，ByteLength函数计算UnicodeString的长度。例如：一旦你不小心传入了一个 AnsiString类型长度为4的字符串，函数会返回8，而不是你期望的长度4。&nbsp;<br><br><br><br>3，Key in ['a'..'z','B','C']<br>这类代码最好替换成CharInSet(Key,['a'..'z','B','C']) 不然会当作AnsiChar处理。<br><br><br><br>4，WideString<br>代码中的所有WideString都考虑替换成String，现在 WideString只是为了与COM兼容而存在，且没有引用计数，性能低下。&nbsp;<br><br><br><br>5，Tnt控件<br>如果你的工程使用了Tnt控件或以前的WideTextPos WideStringReplace之类的东西都替换成标准的吧，不用曲线救国了。&nbsp;<br><br><br><br><br><br><br><br>待续…………&nbsp;<br><br><br><br>---------经过修改，可以在Delphi2010下运作的第三方组件--------------<br><br><br><br>1，PNGDelphi<br><br>2，EmbeddedWB&nbsp;<br><br>3，SynEdit的语法高亮组件 unihighlighter<br><br>4，JEDI Win32API Header&nbsp;<br><br><br><br>这些组件现在可以在Delphi2010下运作了。<br><br>6，引用AnsiStrings单元<br>如果你有必要使用 AnsiLowerCase AnsiCompareStr之类的函数，一定要引用AnsiStrings单元。<br><br>如果你不引用该单元，即便编译不报错，你实际上是用的还是Unicode版本的函数，会有隐式的转化。不信你打开参数自动完成，看看IDE提示给你的类型是什么？天啊AnsiLowerCase参数竟然还是String，而不是AnsiString。看来Delphi2010太迫切的要抛弃Ansi字符串了，以至于你不引用AnsiStrings单元，所有Ansixxxx函数实际上还是Unicode版本。<br><br><br><br>7，AnsiCopy AnsiPos AnsiDelete<br>不要用AnsiCopy AnsiPos AnsiDelete，因为Copy Pos Delete三个函数已经有了For Ansi的重载。<br><br><br><br>8，把Char转化为小写用什么？&nbsp;&nbsp;<br>答案：试试看Character单元的新函数 ToUpper ToLower。以前我都是用System里面的UpCase函数，现在依然可用不过却找不到LowCase DownCase之类的函数，困扰我好久好久。索性全使用Character单元提供的新函数吧。<br><br><br><br>9，编译期警告：[DCC Warning] Unit1.pas(31): W1057 Implicit string cast from 'AnsiString' to 'string'<br>如果你的代码中包含了两种字符串（Unicode、Ansi）之间进行隐式转化的时候就会出现该提示。<br><br>如下代码就会触发该警告：<br><br><br><br>var Unicode:String; Ansi:AnsiString; begin Ansi:='test..'; Unicode:=Ansi;&nbsp;<br><br><br>把旧版本的Delphi项目升级到2010，我通常都是借助编译警告来快速寻找需要改动的部分。通常你可以把赋值双方都声明为String(默认影射到UnicodeString)，就可以避免该警告。但如果你确定必须在此处保留Ansi并进行转化的时候，建议你显式的转化他们（例如：Unicode:=String(Ansi);），这样可以避免该警告，方便你在升级过程中继续寻找其他需要修改的地方。<br><br><br><br>10，Readln Writeln 写入文件时候要注意<br>如果你传给Writeln一个AnsiString，那么它也会在文件中写入AnsiString，那么你读取得时候就必须传给Readln一个AnsiString的类型，否则就是乱码。例如旧工程的配置文件是Ansi的，而你已经把相关读取配置的代码升级为支持Unicode，那么运行工程前你首先要用记事本之类的工具把配置文件另存为成Unicode编码。当然你还要注意跳过Unicode文件头的两个字节FE FF。<br><br><br><br>11，别再用String来操作二进制数据了<br>一定要记住String只是字符串，不要把它当作缓冲区、内存流使用。我的项目中，有很多地方是使用字符串来处理二进制数据，导致在本次升级中颇为费脑。如果当时用TBytes或TStream就好了。<br><br>反面教材：<br><br>var Int1,Int2,Int3,Int4:Integer; Buf:String; begin SetLength(Buf,12); Move(Int1,Buf[1],SizeOf(Integer)); Move(Int1,Buf[5],SizeOf(Integer)); Move(Int1,Buf[9],SizeOf(Integer)); Buf:=Buf+'前面有3个Integer。';&nbsp;<br><br><br>12，还是PChar<br>注意在2010中是这样的：<br><br>PChar= Pointer to a WideChar array;<br><br>PAnsiChar = Pointer to a AnsiChar array;<br><br>如果你还像是在Delphi 7中那样：PChar(AnsiString)那后果过是很严重的。</span></span></span></span></p></div>
<p>转载于:https://www.cnblogs.com/zerovirs/p/6791342.html</p>                                    </div>
                    </div>


</div>


</body></html>