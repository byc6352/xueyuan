<html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>免杀，加壳 - ckkyjtqlt的专栏 - CSDN博客</title>
  <link href="images/style.css" rel="stylesheet">
</head>

<body class="stackedit"><div class="stackedit__html">

<div class="article_content clearfix" id="article_content" style="overflow: hidden;">
                                    <!--一个博主专栏付费入口-->
             
             <!--一个博主专栏付费入口结束-->
            <link href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css" rel="stylesheet">
                                        <link href="https://csdnimg.cn/release/phoenix/template/css/ck_htmledit_views-d284373521.css" rel="stylesheet">
                <div class="htmledit_views" id="content_views">
                                            
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
介绍下加壳、脱壳以及如何病毒免杀技术与原理</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
在自然界中，我想大家对壳这东西应该都不会陌生了，由上述故事，我们也可见一斑。自然界中植物用它来保护种子，动物用它来保护身体等等。同样，在一些计算机软件里也有一段专门负责保护软件不被非法修改或反编译的程序。它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。就像动植物的壳一般都是在身体外面一样理所当然（但后来也出现了所谓的“壳中带籽”的壳）。由于这段程序和自然界的壳在功能上有很多相同的地方，基于命名的规则，大家就把这样的程序称为“壳”了。就像计算机病毒和自然界的病毒一样，其实都是命名上的方法罢了。从功能上抽象，软件的壳和自然界中的壳相差无几。无非是保护、隐蔽壳内的东西。而从技术的角度出发，壳是一段执行于原始程序前的代码。原始程序的代码在加壳的过程中可能被压缩、加密……。当加壳后的文件执行时，壳－这段代码先于原始程序运行，他把压缩、加密后的代码还原成原始程序代码，然后再把执行权交还给原始代码。软件的壳分为加密壳、压缩壳、伪装壳、多层壳等类，目的都是为了隐藏程序真正的OEP（入口点，防止被破解）。关于“壳”以及相关软件的发展历史请参阅吴先生的《一切从“壳”开始》。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
（一）壳的概念</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
作者编好软件后，编译成exe可执行文件。<br>1.有一些版权信息需要保护起来，不想让别人随便改动，如作者的姓名，即为了保护软件不被破解，通常都是采用加壳来进行保护。<br>2.需要把程序搞的小一点，从而方便使用。于是，需要用到一些软件，它们能将exe可执行文件压缩，&nbsp;<br>3.在黑客界给木马等软件加壳脱壳以躲避杀毒软件。实现上述功能，这些软件称为加壳软件。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
（二）加壳软件最常见的加壳软件</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
ASPACK ，UPX，PEcompact 不常用的加壳软件WWPACK32；PE-PACK ；PETITE NEOLITE</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
（三）侦测壳和软件所用编写语言的软件</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
因为脱壳之前要查他的壳的类型。&nbsp;<br>1.侦测壳的软件fileinfo.exe 简称fi.exe（侦测壳的能力极强）。&nbsp;<br>2.侦测壳和软件所用编写语言的软件language.exe（两个功能合为一体，很棒），推荐language2000中文版（专门检测加壳类型）。&nbsp;<br>3.软件常用编写语言Delphi，VisualBasic（VB）---最难破，VisualC（VC）。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
（四）脱壳软件</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
软件加壳是作者写完软件后，为了保护自己的代码或维护软件产权等利益所常用到的手段。目前有很多加壳工具，当然有盾，自然就有矛，只要我们收集全常用脱壳工具，那就不怕他加壳了。软件脱壳有手动脱和自动脱壳之分，下面我们先介绍自动脱壳，因为手动脱壳需要运用汇编语言，要跟踪断点等，不适合初学者，但我们在后边将稍作介绍。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
加壳一般属于软件加密，现在越来越多的软件经过压缩处理，给汉化带来许多不便，软件汉化爱好者也不得不学习掌握这种技能。现在脱壳一般分手动和自动两种，手动就是用TRW2000、TR、SOFTICE等调试工具对付，对脱壳者有一定水平要求，涉及到很多汇编语言和软件调试方面的知识。而自动就是用专门的脱壳工具来脱，最常用某种压缩软件都有他人写的反压缩工具对应，有些压缩工具自身能解压，如UPX；有些不提供这功能，如：ASPACK，就需要UNASPACK对付，好处是简单，缺点是版本更新了就没用了。另外脱壳就是用专门的脱壳工具来对付，最流行的是PROCDUMP
 v1.62 ，可对付目前各种压缩软件的压缩档。在这里介绍的是一些通用的方法和工具，希望对大家有帮助。我们知道文件的加密方式，就可以使用不同的工具、不同的方法进行脱壳。下面是我们常常会碰到的加壳方式及简单的脱壳措施，供大家参考：脱壳的基本原则就是单步跟踪，只能往前，不能往后。脱壳的一般流程是：查壳-&gt;寻找OEP-&gt;Dump-&gt;修复找OEP的一般思路如下：先看壳是加密壳还是压缩壳，压缩壳相对来说容易些，一般是没有异常，找到对应的popad后就能到入口，跳到入口的方式一般为。我们知道文件被一些压缩加壳软件加密，下一步我们就要分析加密软件的名称、版本。因为不同软件甚至不同版本加的壳，脱壳处理的方法都不相同。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
常用脱壳工具：</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
1.文件分析工具（侦测壳的类型）：Fi，GetTyp，peid，pe-scan，&nbsp;<br>2.OEP入口查找工具：SoftICE，TRW，ollydbg，loader，peid&nbsp;<br>3.dump工具：IceDump，TRW，PEditor，ProcDump32，LordPE&nbsp;<br>4.PE文件编辑工具PEditor，ProcDump32，LordPE&nbsp;<br>5.重建Import Table工具：ImportREC，ReVirgin&nbsp;<br>6.ASProtect脱壳专用工具：Caspr（ASPr V1.1-V1.2有效），Rad（只对ASPr V1.1有效），loader，peid&nbsp;<br>（1）Aspack： 用的最多，但只要用UNASPACK或PEDUMP32脱壳就行了&nbsp;<br>（2）ASProtect+aspack：次之，国外的软件多用它加壳，脱壳时需要用到SOFTICE+ICEDUMP，需要一定的专业知识，但最新版现在暂时没有办法。&nbsp;<br>（3）Upx： 可以用UPX本身来脱壳，但要注意版本是否一致，用-D 参数&nbsp;<br>（4）Armadill： 可以用SOFTICE+ICEDUMP脱壳，比较烦&nbsp;<br>（5）Dbpe： 国内比较好的加密软件，新版本暂时不能脱，但可以破解&nbsp;<br>（6）NeoLite： 可以用自己来脱壳&nbsp;<br>（7）Pcguard： 可以用SOFTICE+ICEDUMP+FROGICE来脱壳&nbsp;<br>（8）Pecompat： 用SOFTICE配合PEDUMP32来脱壳，但不要专业知识&nbsp;<br>（9）Petite：有一部分的老版本可以用PEDUMP32直接脱壳，新版本脱壳时需要用到SOFTICE+ICEDUMP，需要一定的专业知识 。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
（10）WWpack32：和PECOMPACT一样其实有一部分的老版本可以用PEDUMP32直接脱壳，不过有时候资源无法修改，也就无法汉化，所以最好还是用SOFTICE配合 PEDUMP32脱壳</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
我们通常都会使用Procdump32这个通用脱壳软件，它是一个强大的脱壳软件，他可以解开绝大部分的加密外壳，还有脚本功能可以使用脚本轻松解开特定外壳的加密文件。另外很多时候我们要用到exe可执行文件编辑软件ultraedit。我们可以下载它的汉化注册版本，它的注册机可从网上搜到。ultraedit打开一个中文软件，若加壳，许多汉字不能被认出 ultraedit打开一个中文软件，若未加壳或已经脱壳，许多汉字能被认出 ultraedit可用来检验壳是否脱掉，以后它的用处还很多，请熟练掌握例如，可用它的替换功能替换作者的姓名为你的姓名注意字节必须相等，两个汉字替两个，三个替三个，不足处在ultraedit编辑器左边用00补。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
常见的壳脱法：</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
1.aspack壳 脱壳可用unaspack或caspr 1.unaspack ，使用方法类似lanuage，傻瓜式软件，运行后选取待脱壳的软件即可. 缺点：只能脱aspack早些时候版本的壳，不能脱高版本的壳 2.caspr第一种：待脱壳的软件（如aa.exe）和caspr.exe位于同一目录下，执行windows起始菜单的运行，键入 caspr aa.exe脱壳后的文件为aa.ex_，删掉原来的aa.exe，将aa.ex_改名为aa.exe即可。使用方法类似fi
 优点：可以脱aspack任何版本的壳，脱壳能力极强缺点：Dos界面。第二种：将aa.exe的图标拖到caspr.exe的图标上***若已侦测出是aspack壳，用unaspack脱壳出错，说明是aspack高版本的壳，用caspr脱即可。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
2.upx壳 脱壳可用upx待脱壳的软件（如aa.exe）和upx.exe位于同一目录下，执行windows起始菜单的运行，键入upx -d aa.exe。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
3.PEcompact壳 脱壳用unpecompact 使用方法类似lanuage傻瓜式软件，运行后选取待脱壳的软件即可。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
4.procdump 万能脱壳但不精，一般不要用使用方法：运行后，先指定壳的名称，再选定欲脱壳软件，确定即可脱壳后的文件大于原文件由于脱壳软件很成熟，手动脱壳一般用不到。一.关于免杀的来源<br>
为了让我们的木马在各种杀毒软件的威胁下活的更久.<br>
二.什么叫免杀和查杀<br>
可分为二类:<br>
1.文件免杀和查杀:不运行程序用杀毒软件进行对该程序的扫描，所得结果。<br>
2.内存的免杀和查杀:判断的方法1&gt;运行后,用杀毒软件的内存查杀功能.<br>2&gt;用OD载入,用杀毒软件的内存查杀功能.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
三.什么叫特征码</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
1.含意:能识别一个程序是一个病毒的一段不大于64字节的特征串.<br>
2.为了减少误报率,一般杀毒软件会提取多段特征串,这时,我们往往改一处就可达到<br>
免杀效果,当然有些杀毒软件要同时改几处才能免杀.(这些方法以后详细介绍)<br>
3.下面用一个示意图来具体来了解一下特征码的具体概念</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
四.特征码的定位与原理</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
1.特征码的查找方法:文件中的特征码被我们填入的数据（比如0）替换了，那杀毒软<br>
件就不会报警，以此确定特征码的位置</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
2.特征码定位器的工作原理:原文件中部分字节替换为0，然后生成新文件，再根据杀<br>
毒软件来检测这些文件的结果判断特征码的位置</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
五.认识特征码定位与修改的工具</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
1.CCL(特征码定位器)<br>
2.OOydbg (特征码的修改)<br>
3.OC用于计算从文件地址到内存地址的小工具.<br>
4.UltaEdit-32(十六进制编辑器,用于特征码的手工准确定位或修改)</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
六.特征码修改方法</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
特征码修改包括文件特征码修改和内存特征码修改，因为这二种特征码的修改方法<br>
是通用的。所以就对目前流行的特征码修改方法作个总节。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
方法一:直接修改特征码的十六进制法<br>
1.修改方法:把特征码所对应的十六进制改成数字差1或差不多的十六进制.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
2.适用范围:一定要精确定位特征码所对应的十六进制,修改后一定要<a title="软件测试知识库" class="replace_word" style="color: rgb(223, 52, 52); font-weight: bold; text-decoration: none;" href="http://lib.csdn.net/base/softwaretest" rel="nofollow" data-token="5bbed3e15cd9883adccbdb831025279d">测试</a>一下能<br>
否正常使用.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
方法二:修改字符串大小写法<br>
1.修改方法:把特征码所对应的内容是字符串的,只要把大小字互换一下就可以了.<br>
2.适用范围:特征码所对应的内容必需是字符串,否则不能成功.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
方法三:等价替换法<br>
1.修改方法:把特征码所对应的汇编指令命令中替换成功能类拟的指令.<br>
2.适用范围:特征码中必需有可以替换的汇编指令.比如JN,JNE 换成JMP等.<br>
如果和我一样对汇编不懂的可以去查查8080汇编手册.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
方法四:指令顺序调换法<br>
1.修改方法:把具有特征码的代码顺序互换一下.<br>
2.适用范围:具有一定的局限性,代码互换后要不能影响程序的正常执行</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
方法五:通用跳转法<br>
1.修改方法:把特征码移到零区域(指代码的空隙处),然后一个JMP又跳回来执行.<br>
2.适用范围:没有什么条件,是通用的改法,强烈建议大家要掌握这种改法.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
七.木马免杀的综合修改方法</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
文件免杀方法：<br>
1.加冷门壳<br>
2.加花指令<br>
3.改程序入口点<br>
4.改木马文件特征码的5种常用方法<br>
5.还有其它的几种免杀修改技巧</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
内存免杀方法：</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
修改内存特征码：<br>
方法1&gt;直接修改特征码的十六进制法<br>
方法2&gt;修改字符串大小写法<br>
方法3&gt;等价替换法<br>
方法4&gt;指令顺序调换法<br>
方法5&gt;通用跳转法<br>
木马的免杀[学用CLL定位文件和内存特怔码]</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
1.首先我们来看下什么叫文件特征码.<br>
一般我们可以这样认为，一个木马程序在不运行的情况下，用杀毒软件查杀，若报警为病毒，说明存在该查毒软件的文件特征码的。<br>
2.特征码的二种定位方法.<br>
手动定位和自动定位<br>
3.文件特征码的定位技巧.<br>
通常用手动确定大范围，用自动精确定位小范围.<br>
下面分别用瑞星和卡巴为例，实例演示并结合手动定位和自动定位二种方法来准确定位文件特征码。要定位的对像以下载者为例。<br>
用卡巴来定位文件特征码<br>
⑴.手动定位：<br>
1&nbsp;打开CLL<br>
2&nbsp;选择设置中的 总体参数 ，，，，，选中文件特征码手动定位，，，，以及路径</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
3选中设置中的 手动参数，，，，，选择替换方式 选中，，，总共生成规定个数的文件，，，生成个数为1000</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
4选择文件中的 特征码检测，，文件特征码检测，，，打开程序（要定位特证码的程序）<br>
5在弹出的PE窗口中 直接点确定 ，之后弹出的窗口在点确定<br>
6然后等CLL生成完毕之后用杀毒软件进行查杀<br>
7在CLL中选 操作，结果定位，选中刚刚用来存放检测结果的文件夹<br>
8在CLL中选<br>
文件免杀之加花指令法</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
一.花指令相关知识：&nbsp;<br>
　其实是一段垃圾代码，和一些乱跳转，但并不影响程序的正常运行。加了花指令后，使一些杀毒软件无法正确识别木马程序，从而达到免杀的效果。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
二.加花指令使木马免杀制作过程详解：<br>
　　第一步：配置一个不加壳的木马程序。<br>
　　第二步：用OD载入这个木马程序，同时记下入口点的内存地址。<br>
　　第三步：向下拉滚动条，找到零区域（也就是可以插入代码的都是0的空白地方）。并记下零区域的起始内存地址。<br>
　　第四步：从这个零区域的起始地址开始一句一句的写入我们准备好的花指令代码。<br>
　　第五步：花指令写完后，在花指令的结束位置加一句：JMP　刚才OD载入时的入口点内存地址。<br>
　　第六步：保存修改结果后，最后用PEditor这款工具打开这个改过后的木马程序。在入口点处把原来的入口地址改成刚才记下的零区域的起始内存地址，并按应用更改。使更改生效。<br>
　　　　　　　　<br>
三.加花指令免杀技术总节：<br>
　1.优点：通用性非常不错，一般一个木马程序加入花指令后，就可以躲大部分的杀毒软件，不像改特征码，只能躲过某一种杀毒软件。<br>
　2.缺点：这种方法还是不能过具有内存查杀的杀毒软件，比如瑞星内存查杀等。<br>
　3.以后将加花指令与改入口点，加壳，改特征码这几种方法结合起来混合使用效果将非常不错。<br>
四.加花指令免杀要点：<br>
由于黑客网站公布的花指令过不了一段时间就会被杀软辨认出来，所以需要你自己去搜集一些不常用的花指令，另外目前还有几款软件可以自动帮你加花，方便一些不熟悉的朋友，例如花指令添加器等。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
五.常见花指令代码<br>
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>
1。 VC++ 5.0<br>
PUSH EBP&nbsp;<br>
MOV EBP,ESP&nbsp;<br>
PUSH -1&nbsp;<br>
push 515448&nbsp;<br>
PUSH 6021A8&nbsp;<br>
MOV EAX,DWORD PTR FS:[0]&nbsp;<br>
PUSH EAX&nbsp;<br>
MOV DWORD PTR FS:[0],ESP&nbsp;<br>
ADD ESP,-6C&nbsp;<br>
PUSH EBX&nbsp;<br>
PUSH ESI&nbsp;<br>
PUSH EDI&nbsp;<br>
jmp 跳转到程序原来的入口点<br>
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>
2。c ++<br>
push ebp<br>
mov ebp,esp<br>
push -1<br>
push 111111<br>
push 222222<br>
mov eax,fs:[0]<br>
push eax<br>
mov fs:[0],esp<br>
pop eax<br>
mov fs:[0],eax<br>
pop eax<br>
pop eax<br>
pop eax<br>
pop eax<br>
mov ebp,eax<br>
jmp 跳转到程序原来的入口点<br>
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>
3。跳转<br>
somewhere:&nbsp;<br>nop&nbsp;/"胡乱"跳转的开始...<br>jmp 下一个jmp的地址&nbsp;/在附近随意跳<br>jmp ...&nbsp;/...<br>jmp 原入口的地址&nbsp;/跳到原始oep<br>
--------------------------------------------------<br>
新入口: push ebp<br>mov ebp,esp<br>inc ecx<br>push edx<br>nop<br>pop edx<br>dec ecx<br>pop ebp<br>inc ecx<br>loop somewhere&nbsp;/跳转到上面那段代码地址去！<br>
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>
4。Microsoft Visual C++ 6.0<br>
push ebp<br>
mov ebp,esp<br>
PUSH -1<br>
PUSH 0<br>
PUSH 0<br>
MOV EAX,DWORD PTR FS:[0]<br>
PUSH EAX<br>
MOV DWORD PTR FS:[0],ESP<br>
SUB ESP,68<br>
PUSH EBX<br>
PUSH ESI<br>
PUSH EDI<br>
POP EAX<br>
POP EAX<br>
POP EAX<br>
ADD ESP,68<br>
POP EAX<br>
MOV DWORD PTR FS:[0],EAX<br>
POP EAX<br>
POP EAX<br>
POP EAX<br>
POP EAX<br>
MOV EBP,EAX<br>
JMP 原入口<br>
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>
5。<br>
在mov ebp,eax<br>
后面加上<br>
PUSH EAX&nbsp;<br>
POP EAX<br>
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&nbsp;<br>
6.<br>
push ebp<br>
mov ebp,esp<br>
add esp,-0C<br>
add esp,0C<br>
mov eax,403D7D<br>
push eax<br>
retn<br>
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>
push ebp<br>
mov ebp,esp<br>
push -1<br>
push 00411222<br>
push 00411544<br>
mov eax,dword ptr fs:[0]<br>
push eax<br>
mov dword ptr fs:[0],esp<br>
add esp,-6C<br>
push ebx<br>
push esi<br>
push edi<br>
add byte ptr ds:[eax],al<br>
jo 入口<br>
jno 入口<br>
call 下一地址<br>
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>
7.<br>
push ebp<br>
nop<br>
nop<br>
mov ebp,esp<br>
inc ecx<br>
nop<br>
push edx<br>
nop<br>
nop<br>
pop edx<br>
nop<br>
pop ebp<br>
inc ecx<br>
loop 任意地址<br>
nop<br>
nop<br>
———————————————<br>
nop<br>
nop<br>
jmp 下一个jmp的地址&nbsp;/在附近随意跳<br>
nop<br>
jmp 下一个jmp的地址&nbsp;/在附近随意跳<br>
nop<br>
jmp 下一个jmp的地址&nbsp;/在附近随意跳<br>
jmp 入口<br>
文件免杀之加壳与改入口点法</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
<br>
一.壳的相关知识：<br>
1.壳的分类：压缩壳和加密壳<br>
2.壳的作用：保护和文件免杀&nbsp;<br>
二.加壳免杀的几个弱点<br>
1.不能躲过像瑞星这类具有内存查杀功能的杀毒软件。<br>
2.一般不能躲过卡巴的查杀<br>
因为卡巴采用了一种叫虚拟机技术。首先把加了多层壳的木马程序在虚拟机环境下运行一下，这样木马程序就会现出本来面目，这样无论你加了多少层壳，在运行后程序还是要暴露自已的。所以大家在加壳测试过程中也会发现，能过其它的多种杀毒软件，但卡巴始终很难过，其原因就是卡巴的虚拟技术在作怪。<br>
三.是不是现在的加壳免杀已失去意义<br>
每种免杀技术都有他的缺点和优点，比如加壳，首先要找到比较生僻的壳,而且可能以后很快被查杀.同时也不能过内存查杀,也很难过卡巴.但它操作方便,通用性好加一个壳,可能过好几个杀毒软件.又比如修改特征码.首先操作比较烦,要定位,要修改,改好后还要测试是否能正常使用.同时针对性非常强.只能针对某一种杀毒软件的免杀,各种杀毒软件的特征码都不一样,所以要躲过多种杀毒软件查杀,就要分别定位,修改每种杀毒软件的特征码.这样是相当麻烦的.但它可以通过修改特征码来躲过瑞星内存和卡巴的查杀.<br>
所以以后免杀技术会把加壳,加花指令,改入口点,改特征码这几种方法结合起来使用.对付瑞星的内存查杀,我们可以修改内存特征码,对付卡巴的虚拟机技术.我们可以修改卡巴的特征码.在加上加冷门壳,加花指令,改入口点.综合这些方法就可以打造金钢不死之身!<br>
四.加壳免杀实例演示部分:<br>
1.加生僻壳免杀:实例演示<br>
2.加伪装壳免杀:实例演示<br>
3.多重加壳免杀:（用木马彩衣进行多重加壳）</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
五.改入口点免杀法:<br>
1.改入口点免杀原理:杀毒软件一般都检测病毒还原之后的代码,而且一般都把代码段开始的前40个字节作为特征值.入口点改变了,说明也就破坏了特征码,这样就达到免杀的效果.<br>
2.改入口点免杀方法一:入口地址加1法.<br>
操作步骤:<br>
第一步:配置一个无壳的木马服务端.<br>
第二步:用PEditor打开木马程序服务端.在入口点处的地址加1.然后点应用更改就可以了.<br>
评论:该方法对不同木马程序,有不同的效果,其它杀毒软件一般都可以躲过,但有些程序改过后还是被卡巴查杀.同时也不能过内存查杀,但以后结合加花指令,加壳等等方法,效果将非常不错.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
<br>
3.改入口点免杀方法二:变换入口地址法.<br>
操作步骤:<br>
第一步:用OD载入无壳木马程序服务端.<br>
第二步:把入口点的开始二句代码(大都为push ebp&nbsp;mov ebp,esp).移到零区域也是就空白区域地方.并记下零区域的内存地址.同时在后面加一句跳转命令:JMP 到第三条指令的地址.<br>
第三步:然后修正并保存,最后用PEditor打开该程序.把入口点改成刚才在零区域记下的内存地址.<br>
评论:该方法效果比方法一要好.经测试,用方法一改过后被卡巴查出来,用方法二就查不出来. 以后可以结合加花指令,加壳,改特征码,打造金钢不死之身!</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
<br>
采用以上的方法可以躲过不少杀毒软件的追杀，并且方便快速，又很简单，所以是免杀里非常主要的手段，但是一定要检查文件是不是能够正常运行。<br>
免杀新技术[虚拟机加密免杀]和[壳中改籽]</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
一 虚拟机加密免杀<br>
最新免杀技术——虚拟机加密代码应用并非传统的修改特征码，也不是修改入口点+花指令，更不是<br>
加壳压缩！是最新的一种免杀技术！借于这种技术你可以千变万化，是免杀对新手来说更为简单！<br>
大家对虚拟机vmprotect是否有所了解，这个是最新的加密工具！可以加密PE文件中任何一句或一段代码<br>
自然可以给我们用来免杀了！<br>
免杀工具：vmprotect1.07或1.06 PEID UPX<br>
免杀步骤：原理说明：加密区段代码使杀毒软件无法识别！你可以找特征码，找到后加密特征码的代码！<br>
用PEID查看入口点：假如这里的入口点是0007DB74 基址是 00400000<br>
3.用虚拟机vmprotect打开要免杀的文件，添加地址0047DB74=00400000+0007DB74 基址+入口点&nbsp;<br>
4.选代码区域-&gt;转存-&gt;F9保存<br>
5.测试运行-&gt;可以成功运行<br>
6.用UPX压缩一下，缩小体积，OK 免杀成功&nbsp;<br>
总结：虚拟机加密代码是比较新的免杀技术，可以和其他免杀技术有机的集合在一起，让你的木马变成金刚不坏.大家要多多掌握。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
二 壳中改籽技术免杀<br>
这种免杀很少有人用，所以免杀效果非常好，各大黑客网站也很少见到介绍，这里我把别人做黑洞免杀的文章发到这里，供大家研究.估计是浩天写的文章<br>
先讲一下为什么这种技术叫“壳中改籽”。配置一个黑洞的服务端，然后用PEiD.exe来查看它是用什么加的壳，查到是UPX加的变态壳，程序的区段都给隐藏了，那么先得给黑洞服务端脱壳。用 upxfix.exe打开它，然后在Decompress method里面选择5，点击fix，这样就修复了。再用PEiD.exe查一下，看现在可以看到区段了吧。<br>
为什么我一再提到这个区段呢？其实它就是文章的重点，也就是壳里面的籽。继续脱壳，用UPXShell打开修复好的黑洞服务端，点击解压缩，完成后我们可以看到程序由原来的201 kb变成了506 KB ，大了一倍多。<br>
有人可能要问为什么一定要给它脱壳呢？直接修改不可以吗？其实主要是因为黑洞的服务端里还有一个用做键盘记录的dll文件，它也要做免杀处理。用 Resscope1.92打开黑洞的服务端，这个可是绝好的exe资源编辑器啊，先选择dllfile里面的getkey，然后点击文件→导出资源，这样dll文件就导出来了。它也是用upx加的变态壳，因为区段被加密了，所以我们也要给它脱壳，再加壳。脱壳的过程和先前脱黑洞服务端一样先用upxfix.exe打开它，但是这里注意在Decompress method里面，不要选择5，而是选择2修复，不然的话就脱不了壳了。<br>
接着用UPXShell解压缩，现在dll文件的大小由原来的11 kb变成了18.5 kb，然后再用UPXShell重新给它加上壳。<br>
三、修改upx壳里面的籽<br>
把UPX加过壳的dll文件，用PEiD.exe打开查看，这里有几个数据需要我们记录，等下和修改后的文件做比较用。<br>
先分别把程序入口点：000C220、文件偏移量：00002620 ，记录下来，然后点击查看EP区段，在区段查看上面再点右键选择cave查找器，把upx壳区段upx1的RVA：0000C3B5、偏移：000027B5等参数也记录下来。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
关键的时刻到了，reloc.exe闪亮登场。因为reloc 是一款命令下的工具，所以为了操作方便，我建议大家写一个bat文件和reloc放在同一目录。我们开始记录的数据现在派上用场了，编辑bat文件格式如下：<br>
reloc 待修改程序 $程序入口 $文件偏移量 $壳的区段入口 $区段偏移 参数<br>
那么对应我们的黑洞键盘记录dll文件所记录的数据，这个bat就应该这样写：<br>
reloc 键盘记录.dll $C220 $2620 $C3B5 $27B5 5<br>
数据前面的零不要写到bat里面，另外最后面的这个参数大家注意，其实它是设置修改时的偏移量的，一般dll文件选择5，exe文件选择5-9之间的数，一般选择6就好了。<br>
设置完了，我们运行这个bat文件，开始修改。完毕之后我分别用国内和国外最强的杀毒软件江民、诺盾和卡巴斯基对键盘记录.dll进行扫描，它们均未发现病毒，我们的木马成功躲了过去。用PEiD.exe重新打开，可以发现PEiD已经无法分别键盘记录.dll是什么壳了，把原来记录的几个数据和现在对比一下发现程序入口和文件偏移量没有，而壳区段入口和区段偏移却改变。<br>
飘舞的风在上一期的文章里面说道：“peidv0.92是通过每个程序的开头几十个字节来比较是那种壳。”，看来不仅仅如此，peidv0.92还把壳的区段入口开头的几十个字节也作为了用来判断壳的类型的特征代码，杀毒软件也是如此，这样简单修改一下我们的木马就免杀了。<br>
着把这个已经修改好的dll文件，导回到黑洞的服务端,方法和导出dll是一样的，我就不再讲述了，然后把它用UPXShell再次加壳，加壳后的大小为200 kb。<br>
现在可以开始我们的第二次免杀之旅了，同样用PEiD.exe把程序入口、文件偏移量、壳的区段入口、区段偏移，等数据记录下来，写入bat文件。<br>
我的bat是这样写的：<br>
reloc 1.exe $88620 $30A20 $887A3 $30BA3 6<br>
我前面已经讲过了，修改exe文件的时候，参数选择5-9之间的数，一般选择6就好了。现在运行bat文件，黑洞服务端的免杀就全部完成了。用PEiD.exe查看，显示的是“Nothing found”看来PEiD已经不认识它了，再用江民、诺盾和卡巴斯基查杀，均显示无病毒，呵呵，欺骗成功。<br>
四、结语<br>
经过这么简单的修改以后效果是非常好的，相信以后这样的免杀技术将会成为主流技术，因为它简单实用。<br>
分析它实现免杀的原理，不难看出换一个角度思考问题的重要性，从壳的修改转到壳中籽的修改，不能不说这是一种创新，<br>
它使木马的免杀之路变宽了。最后谢谢 “朋友的家”提供一款这样优秀的工具。如果大家能够把这种技术和我前面提到的另外三种结合起来使用，相信它将是无懈可击的免杀新技术之OD一半定位法</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
不知道是那位牛人想出来把这方法用到木马免杀上，这个方法让很多不会用偏移定位特怔码的朋友也能够很容易掌握到特怔码的位置，实在是很高明又很简单的免杀好方法.这里我就根据他的方法详细介绍OD一半定位法&nbsp;<br>所谓OD一半定位法很简单，就是用OD载入需要做免杀处理的文件，用NOP填充一半的代码然后保存，接着用杀毒软件查毒，如果有毒就在把另外一半用NOP填充，如果没报毒就证明特怔码就在刚刚填充的那一半，然后又对那一半进行1/2的NOP填充，这样不断缩小范围，很容易就找到需要修改的代码部分。如果是做内存免杀就把NOP填充好的文件用OD打开进行内存杀毒。怎么样？是不是很容易掌握的方法？<br>不过需要注意的是新手用这个方法最好每做一步都把NOP填充的开头和结局部分的地址用纪事本保存，免得一旦忘记又从头来.<br>如果特怔码不止一处，你就要大致定位到有特怔码这一大段，然后把这一段的一半用NOP填充并且保存，接着打开保存的文件对另外一半继续刚刚开始的步骤，这样很快就能够定位出几处特证码所在的位置.<br>
还是那句话，熟练就好，另外需要注意填充后查出的病毒名字有没有改变，如果改变就证明你填充的那段存在特怔码，这样可以省掉不少时间。<br>
文件免杀之文件特征码修改五大法宝</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
方法一:修改字符串大小写法</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
1.修改方法:把特征码所对应的内容是字符串的,只要把大小字互换一下就可以了.<br>
2.适用范围:特征码所对应的内容必需是字符串,否则不能成功.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
　　 方法二:直接修改特征码的十六进制法<br>
1.修改方法:把特征码所对应的十六进制改成数字差1或差不多的十六进制.<br>
2.适用范围:一定要精确定位特征码所对应的十六进制,修改后一定要测试一下能否正常使用.<br>
　<br>
　　 方法三:指令顺序调换法<br>
1.修改方法:把具有特征码的代码顺序互换一下.<br>
2.适用范围:具有一定的局限性,代码互换后要不能影响程序的正常执行。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
　　方法四:通用跳转法<br>
1.修改方法:把特征码移到零区域(指代码的空隙处),然后一个JMP又跳回来执行.<br>
2.适用范围:没有什么条件,是通用的改法,强烈建议大家要掌握这种改法.<br>
　　<br>
　　方法五:等价替换法<br>
1.修改方法:把特征码所对应的汇编指令命令中替换成功能类似的指令.<br>
2.适用范围:特征码中必需有可以替换的汇编指令.替换后指令功能要不变比如JN,JNE 换成JMP，这里要对汇编要比较熟悉，读懂指令后可以替换功能相同的指令。也可以去查8080汇编手册[计算机专栏里有]</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
实战特怔码免杀<br>
第一步：首先用内存定位法来准确定位瑞星内存特征码的具体位置<br>
　 第一阶段：自动参数中，生成文件间隔秒数设为4，最小替换字节数设为100字节。（主要用于大体定位内存特征码）<br>第二阶段：自动参数中，生成文件间隔秒数设为4.最小替换字节数设为4字节。（主要用于准确定位内存特征码）<br>
第二步：修改特征码<br>
　　　用OD打开文件，找到特怔码所在位置，并且判断适合用那种方法修改，如果对方法不太熟悉，并且特怔码不止一处，那就需要你改一处就保存并且在虚拟机里试验能否正常运行[虚拟机可是做免杀的必备工具，强烈建议你安装，因为你不可能就在自己的机器上运行木马吧？在说也不可能在你机器上同时安装N种杀软，那你机器不慢死，更重要还可以用来试验别人提供的软件有没有木马]<br>
木马免杀技术之独门绝技</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
<br>
绝技一：快速搞定瑞星文件查杀&nbsp;<br>
操作步骤：<br>
　第一步：用OD载入，来到程序的入口点。<br>
　第二步：把入口点的第一句PUSH　EBP　改成POP　EBP　然后保存就可以躲过瑞星的表面查杀。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
绝技二：快速定位与修改瑞星内存特征码<br>
原理：因为目前的内存查杀杀毒软件，只有瑞星才能威胁到我们的木马。也就是说只要搞定瑞星的内存查杀，那我们的木马在内存就畅通无阻了. 但由于技术原因,目前瑞星的内存特征码在90%以上把字符串作为病毒特征码,<br>
这样对我们的定位和修改带来了方便.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
操作步骤:&nbsp;<br>
第一步:首先用特征码定位器大致定位出瑞星内存特征码位置.<br>
第二步:然后用UE打开,找到这个大致位置,看看,哪些方面对应的是字符串,用0替换后再用内存查杀进行查杀.直到找到内存特征码后,只要把字符串的大小写互换就能达到内存免杀效果.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
绝技三:如何快速躲过诺顿的查杀<br>
诺顿的查杀特点:大家有时候会发现,通过改特征码,加花指令,改内存特征码,等等,卡巴,江民,金山,瑞星都过了,但无论如何都过不了诺顿,这时候是不是感到很纳闷.其实诺顿特征码的定义和其它杀毒软件不一样,其它杀毒软件的特征码都在代码段而只有它把特征码定义在PE头文件里面.而在头文件里面,一般都用字符串作为病<br>
毒特征码,知道了原理,就有下面的二种方法来应付.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
方法一:只要把头文件的字符串的大小字互换一下就可以搞定了.<br>
方法二:有二款压缩软件WinUpack和北斗星,经过他们的压缩,会把我们的木马程序的头文件改的面目全非.所以把我们的木马做好其它的杀毒软件的免杀后,再用这二款压缩软件的压缩就可以躲过诺顿的查杀.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
绝技四:一个不太通用的免杀方法<br>
免杀方法一:把入口点第三句开始的几行(20字节内)汇编代码移到零区域去执行,也达到一定的免杀效果.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
绝技五:用VC++加了花指令后入口点下移法<br>
操作过程:加花指令后,可以把入口点下移好一位,这样可以进一步达到免杀效果.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
一.木马免杀综合方案</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
修改内存特征码---&gt;1&gt;入口点加1免杀法 1&gt;加压缩壳1&gt;---&gt;再加壳或多重加壳<br>2&gt;变化入口地址免杀法 2&gt;加生僻壳---&gt;2&gt;加壳的伪装.<br>3&gt;加花指令法免杀法 3&gt;加压缩壳3&gt;---&gt;打乱壳的头文件<br>4&gt;修改文件特征码免杀法<br>
以上免杀方法可以自由组合成多种不同的免杀方案。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
二.常用免杀方案<br>
1.实例完全免杀方案一：<br>
内存特征码修改＋加UPX壳＋秘密行动打乱壳的头文件。<br>
所需工具：UPX加壳工具，秘密行动<br>
2.完全免杀方案二：<br>
内存特征码修改＋加花指令＋加压缩壳<br>
3.完全免杀方案三：<br>
内存特征码修改＋加压缩壳＋加壳的伪装或多重加壳<br>
4.完全免杀方案四：<br>
内存特征码修改＋去头变换入口点地址＋压缩壳<br>
5.完全免杀方案五：<br>
内存特征码修改＋修改各种杀毒软件特征码＋压缩壳<br>
6.完全变态免杀方案六：<br>
内存特征码修改＋加花指令＋去头变换入口点＋加UPX壳＋用秘密行动打乱壳的头<br>
文件</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
三.解决加花指令后运行出错问题</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
1.分析其原因：我们加花指令时，一般都找代码段最后面的空白代码地方也就是所谓的零区域，然后把我们准备好的花指令填进去，然后一个跳转跳到入口点。但是我们木马的体积比较大，从入口点到最后面零区域的间隔比较远，所以从低部跳到头部由于间隔较远就非常容易出错。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
3.新研究的免杀方法完美的解决了该问题：我把它取名为：中间过渡跳转法</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
实例演示：中间过渡跳转法来修改灰鸽子V1.22版或VIP2.0版。</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
中间过渡中转法实现原理：首先我们在代码段的中间位置,备份部分代码,然后把我们要添加的花指令写进去,写完后,再跳到零区域,在这个零区域填入刚才我们备份好的代码.填完后又要跳回填入花指令的生面.总之一句话:把花指令填在代码中间,被花指令覆盖的代码移到零区域去执行,然后又要跳回来.最后把入口点改成花指令的首地址.这样就算完事了.</p>
<p style="color: rgb(51, 51, 51); line-height: 20px; font-family: simsun;">
4.该新的免杀技术优点:以前的花指令只能填到零区域,也就是说入口点一般都比较后面,所以有时会被卡巴查杀,但有了这种新方法后,程序入口点就变的非常灵活,可以定位在代码段的任何位置,每定位一个新的入口点就是一种新的免杀方案.而且这种方法对付卡巴也很有效.把入口点放到代码段的中间,是杀毒软件万万想不到的,所以免杀效果是最好的.同时他解决了由于跳转太远使程序无法运行的缺</p>
                                    </div>
                    </div>


</div>


</body></html>